


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: CalibratedBirthDeathModel</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">beast.evolution.speciation</a> ]
</div>

<h1>Coverage Summary for Class: CalibratedBirthDeathModel (beast.evolution.speciation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CalibratedBirthDeathModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 524)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CalibratedBirthDeathModel$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CalibratedBirthDeathModel$Type</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 532)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;package beast.evolution.speciation;
<i>2</i>&nbsp;
<i>3</i>&nbsp;
<i>4</i>&nbsp;import java.io.PrintStream;
<i>5</i>&nbsp;import java.util.ArrayList;
<i>6</i>&nbsp;import java.util.Arrays;
<i>7</i>&nbsp;import java.util.List;
<i>8</i>&nbsp;
<i>9</i>&nbsp;import org.apache.commons.math.MathException;
<i>10</i>&nbsp;
<i>11</i>&nbsp;import beast.core.Description;
<i>12</i>&nbsp;import beast.core.Distribution;
<i>13</i>&nbsp;import beast.core.Input;
<i>14</i>&nbsp;import beast.core.Input.Validate;
<i>15</i>&nbsp;import beast.core.parameter.RealParameter;
<i>16</i>&nbsp;import beast.core.util.CompoundDistribution;
<i>17</i>&nbsp;import beast.core.util.Log;
<i>18</i>&nbsp;import beast.evolution.alignment.TaxonSet;
<i>19</i>&nbsp;import beast.evolution.tree.Node;
<i>20</i>&nbsp;import beast.evolution.tree.Tree;
<i>21</i>&nbsp;import beast.evolution.tree.TreeInterface;
<i>22</i>&nbsp;import beast.math.distributions.MRCAPrior;
<i>23</i>&nbsp;import beast.math.statistic.RPNcalculator;
<i>24</i>&nbsp;
<i>25</i>&nbsp;/**
<i>26</i>&nbsp;* @author Joseph Heled
<i>27</i>&nbsp; */
<i>28</i>&nbsp;
<i>29</i>&nbsp;
<b class="nc"><i>30</i>&nbsp;@Description(&quot;Birth-Death prior with calibrated monophyletic clades. With this prior, &quot; +</b>
<i>31</i>&nbsp;        &quot;the marginal distribution of the&quot; +
<i>32</i>&nbsp;        &quot; calibrated nodes (the root age of the clade) is identical to the specified calibration, &quot; +
<i>33</i>&nbsp;        &quot;and the density ratio between trees with equal calibration values is equal to the ratio under the &quot; +
<i>34</i>&nbsp;        &quot;Birth-Death prior.&quot;)
<i>35</i>&nbsp;//@Citation(value = &quot;Heled J, Drummond AJ. Calibrated Tree Priors for Relaxed Phylogenetics and Divergence Time &quot; +
<i>36</i>&nbsp;//        &quot;Estimation. &quot; +
<i>37</i>&nbsp;//        &quot;Syst Biol (2012) 61 (1): 138-149.&quot;, DOI = &quot;10.1093/sysbio/syr087&quot;)
<i>38</i>&nbsp;public class CalibratedBirthDeathModel extends SpeciesTreeDistribution {
<i>39</i>&nbsp;
<b class="nc"><i>40</i>&nbsp;    static enum Type {</b>
<b class="nc"><i>41</i>&nbsp;        NONE(&quot;none&quot;),</b>
<b class="nc"><i>42</i>&nbsp;        OVER_ALL_TOPOS(&quot;full&quot;),</b>
<b class="nc"><i>43</i>&nbsp;        OVER_RANKED_COUNTS(&quot;restricted&quot;);</b>
<i>44</i>&nbsp;
<b class="nc"><i>45</i>&nbsp;        Type(final String name) {</b>
<b class="nc"><i>46</i>&nbsp;            this.ename = name;</b>
<i>47</i>&nbsp;        }
<i>48</i>&nbsp;
<i>49</i>&nbsp;        @Override
<i>50</i>&nbsp;		public String toString() {
<b class="nc"><i>51</i>&nbsp;            return ename;</b>
<i>52</i>&nbsp;        }
<i>53</i>&nbsp;
<i>54</i>&nbsp;        private final String ename;
<i>55</i>&nbsp;    }
<i>56</i>&nbsp;
<i>57</i>&nbsp;    // Q2R does this makes sense, or it has to be a realParameter??
<b class="nc"><i>58</i>&nbsp;    final public Input&lt;RealParameter&gt; birthRateInput =</b>
<i>59</i>&nbsp;            new Input&lt;&gt;(&quot;birthRate&quot;, &quot;birth rate - the rate at which new lineages are created as a result of an &quot; +
<i>60</i>&nbsp;                    &quot;existing lineage splitting into two.&quot;, Validate.REQUIRED);
<i>61</i>&nbsp;
<b class="nc"><i>62</i>&nbsp;    final public Input&lt;RealParameter&gt; deathToBirthRatioInput =</b>
<i>63</i>&nbsp;            new Input&lt;&gt;(&quot;relativeDeathRate&quot;, &quot;relative death rate parameter, mu/lambda in birth death model&quot;,
<i>64</i>&nbsp;                    Validate.OPTIONAL);
<i>65</i>&nbsp;
<b class="nc"><i>66</i>&nbsp;    final public Input&lt;RealParameter&gt; sampleProbabilityInput =</b>
<i>67</i>&nbsp;            new Input&lt;&gt;(&quot;sampleProbability&quot;, &quot;sample probability, rho in birth/death model&quot;,
<i>68</i>&nbsp;                    Validate.OPTIONAL);
<i>69</i>&nbsp;
<b class="nc"><i>70</i>&nbsp;    final public Input&lt;List&lt;CalibrationPoint&gt;&gt; calibrationsInput =</b>
<i>71</i>&nbsp;            new Input&lt;&gt;(&quot;calibrations&quot;, &quot;Set of calibrated nodes&quot;, new ArrayList&lt;&gt;());
<i>72</i>&nbsp;
<b class="nc"><i>73</i>&nbsp;    final public Input&lt;Type&gt; correctionTypeInput = new Input&lt;&gt;(&quot;type&quot;, &quot;Type of correction: none for no correction &quot; +</b>
<i>74</i>&nbsp;            &quot;(same as BEAST1), full for Yule-like over calibrated times, and restricted for Yule-like over calibrated&quot; +
<i>75</i>&nbsp;            &quot; times and ranked topology (default &#39;full&#39;). However, &#39;full&#39;&quot; +
<i>76</i>&nbsp;            &quot; is generally slow except for a few special cases, such as a single clade or two nested clades.&quot;,
<b class="nc"><i>77</i>&nbsp;            Type.OVER_ALL_TOPOS, Type.values());</b>
<i>78</i>&nbsp;
<b class="nc"><i>79</i>&nbsp;    final public Input&lt;RPNcalculator&gt; userMarInput = new Input&lt;&gt;(&quot;logMarginal&quot;,</b>
<i>80</i>&nbsp;            &quot;Use provided formula to compute the (log of) the marginal for special cases.&quot;,
<i>81</i>&nbsp;            (RPNcalculator) null);
<i>82</i>&nbsp;
<i>83</i>&nbsp;    // Which correction to apply
<i>84</i>&nbsp;    private Type type;
<i>85</i>&nbsp;
<i>86</i>&nbsp;    // Calibration points, (partially) sorted by set inclusion operator on clades. (remember that partially overlapping clades are not allowed)
<i>87</i>&nbsp;    CalibrationPoint[] orderedCalibrations;
<i>88</i>&nbsp;
<i>89</i>&nbsp;    // taxa of calibrated points, in same order as &#39;orderedCalibrations&#39; above. The clade is represented as an array of integers, where each
<i>90</i>&nbsp;    // integer is the &quot;node index&quot; of the taxon in the tree, that is tree.getNode(xclades[i][k]) is the node for the k&#39;th taxon of the i&#39;th point.
<i>91</i>&nbsp;    private int[][] xclades;
<i>92</i>&nbsp;
<i>93</i>&nbsp;    // taxaPartialOrder[i] contains all clades immediately preceding the i&#39;th clade under clade partial ordering.
<i>94</i>&nbsp;    // (i&#39;th clade is orderedCalibrations[i]/xclades[i]). clades are given as their index into orderedCalibrations (and so into xclades as well).
<i>95</i>&nbsp;    private int[][] taxaPartialOrder;
<i>96</i>&nbsp;
<b class="nc"><i>97</i>&nbsp;    RPNcalculator userPDF = null; //Q2R  but would that work propagation-wise</b>
<i>98</i>&nbsp;
<i>99</i>&nbsp;    // whether to calculated the contribution of each of the calibrations
<i>100</i>&nbsp;    // should be false, when the calibrations come from MRCA priors of a parent CompoundDistribution
<b class="nc"><i>101</i>&nbsp;    boolean calcCalibrations = true;</b>
<i>102</i>&nbsp;
<b class="nc"><i>103</i>&nbsp;    boolean isYule = false;</b>
<i>104</i>&nbsp;
<b class="nc"><i>105</i>&nbsp;    public CalibratedBirthDeathModel() {</b>
<i>106</i>&nbsp;    }
<i>107</i>&nbsp;
<i>108</i>&nbsp;    @Override
<i>109</i>&nbsp;    public void initAndValidate() {
<b class="nc"><i>110</i>&nbsp;        super.initAndValidate();</b>
<i>111</i>&nbsp;
<b class="nc"><i>112</i>&nbsp;        type = correctionTypeInput.get();</b>
<i>113</i>&nbsp;
<b class="nc"><i>114</i>&nbsp;        final TreeInterface tree = treeInput.get();</b>
<i>115</i>&nbsp;
<i>116</i>&nbsp;        // shallow copy. we shall change cals later
<b class="nc"><i>117</i>&nbsp;        final List&lt;CalibrationPoint&gt; cals = new ArrayList&lt;&gt;(calibrationsInput.get());</b>
<b class="nc"><i>118</i>&nbsp;        int calCount = cals.size();</b>
<b class="nc"><i>119</i>&nbsp;        final List&lt;TaxonSet&gt; taxaSets = new ArrayList&lt;&gt;(calCount);</b>
<b class="nc"><i>120</i>&nbsp;        if (cals.size() &gt; 0) {</b>
<b class="nc"><i>121</i>&nbsp;            xclades = new int[calCount][];</b>
<i>122</i>&nbsp;
<i>123</i>&nbsp;            // convenience
<b class="nc"><i>124</i>&nbsp;            for (final CalibrationPoint cal : cals) {</b>
<b class="nc"><i>125</i>&nbsp;                taxaSets.add(cal.taxa());</b>
<b class="nc"><i>126</i>&nbsp;            }</b>
<i>127</i>&nbsp;
<i>128</i>&nbsp;        } else {
<i>129</i>&nbsp;            // find calibration points from prior
<b class="nc"><i>130</i>&nbsp;            for (final Object beastObject : getOutputs()) {</b>
<b class="nc"><i>131</i>&nbsp;                if (beastObject instanceof CompoundDistribution) {</b>
<b class="nc"><i>132</i>&nbsp;                    final CompoundDistribution prior = (CompoundDistribution) beastObject;</b>
<b class="nc"><i>133</i>&nbsp;                    for (final Distribution distr : prior.pDistributions.get()) {</b>
<b class="nc"><i>134</i>&nbsp;                        if (distr instanceof MRCAPrior) {</b>
<b class="nc"><i>135</i>&nbsp;                            final MRCAPrior _MRCAPrior = (MRCAPrior) distr;</b>
<i>136</i>&nbsp;                            // make sure MRCAPrior is monophyletic
<b class="nc"><i>137</i>&nbsp;                            if (_MRCAPrior.distInput.get() != null) {</b>
<i>138</i>&nbsp;                                // make sure MRCAPrior is monophyletic
<b class="nc"><i>139</i>&nbsp;                                if (!_MRCAPrior.isMonophyleticInput.get()) {</b>
<b class="nc"><i>140</i>&nbsp;                                    throw new IllegalArgumentException(&quot;MRCAPriors must be monophyletic for Calibrated Yule prior&quot;);</b>
<i>141</i>&nbsp;                                }
<i>142</i>&nbsp;                                // create CalibrationPoint from MRCAPrior
<b class="nc"><i>143</i>&nbsp;                                final CalibrationPoint cal = new CalibrationPoint();</b>
<b class="nc"><i>144</i>&nbsp;                                cal.distInput.setValue(_MRCAPrior.distInput.get(), cal);</b>
<b class="nc"><i>145</i>&nbsp;                                cal.taxonsetInput.setValue(_MRCAPrior.taxonsetInput.get(), cal);</b>
<b class="nc"><i>146</i>&nbsp;                                cal.initAndValidate();</b>
<b class="nc"><i>147</i>&nbsp;                                cals.add(cal);</b>
<b class="nc"><i>148</i>&nbsp;                                taxaSets.add(cal.taxa());</b>
<b class="nc"><i>149</i>&nbsp;                                cal.taxa().initAndValidate();</b>
<b class="nc"><i>150</i>&nbsp;                                calCount++;</b>
<b class="nc"><i>151</i>&nbsp;                                calcCalibrations = false;</b>
<b class="nc"><i>152</i>&nbsp;                            } else {</b>
<b class="nc"><i>153</i>&nbsp;                                if (_MRCAPrior.isMonophyleticInput.get()) {</b>
<b class="nc"><i>154</i>&nbsp;                                    Log.warning.println(&quot;WARNING: MRCAPriors must have a distribution when monophyletic for Calibrated Yule prior&quot;);</b>
<i>155</i>&nbsp;                                }
<i>156</i>&nbsp;                            }
<i>157</i>&nbsp;                        }
<b class="nc"><i>158</i>&nbsp;                    }</b>
<i>159</i>&nbsp;                }
<b class="nc"><i>160</i>&nbsp;            }</b>
<b class="nc"><i>161</i>&nbsp;            xclades = new int[calCount][];</b>
<i>162</i>&nbsp;        }
<b class="nc"><i>163</i>&nbsp;        if (calCount == 0) {</b>
<i>164</i>&nbsp;            // assume we are in beauti, back off for now
<i>165</i>&nbsp;            return;
<i>166</i>&nbsp;        }
<i>167</i>&nbsp;
<b class="nc"><i>168</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>169</i>&nbsp;            final TaxonSet tk = taxaSets.get(k);</b>
<b class="nc"><i>170</i>&nbsp;            for (int i = k + 1; i &lt; calCount; ++i) {</b>
<b class="nc"><i>171</i>&nbsp;                final TaxonSet ti = taxaSets.get(i);</b>
<b class="nc"><i>172</i>&nbsp;                if (ti.containsAny(tk)) {</b>
<b class="nc"><i>173</i>&nbsp;                    if (!(ti.containsAll(tk) || tk.containsAll(ti))) {</b>
<b class="nc"><i>174</i>&nbsp;                        throw new IllegalArgumentException(&quot;Overlapping taxaSets??&quot;);</b>
<i>175</i>&nbsp;                    }
<i>176</i>&nbsp;                }
<i>177</i>&nbsp;            }
<i>178</i>&nbsp;        }
<i>179</i>&nbsp;
<b class="nc"><i>180</i>&nbsp;        orderedCalibrations = new CalibrationPoint[calCount];</b>
<i>181</i>&nbsp;
<i>182</i>&nbsp;        {
<b class="nc"><i>183</i>&nbsp;            int loc = taxaSets.size() - 1;</b>
<b class="nc"><i>184</i>&nbsp;            while (loc &gt;= 0) {</b>
<b class="nc"><i>185</i>&nbsp;                assert loc == taxaSets.size() - 1;</b>
<i>186</i>&nbsp;                //  place maximal taxaSets at end one at a time
<b class="nc"><i>187</i>&nbsp;                int k = 0;</b>
<b class="nc"><i>188</i>&nbsp;                for (/**/; k &lt; taxaSets.size(); ++k) {</b>
<b class="nc"><i>189</i>&nbsp;                    if (isMaximal(taxaSets, k)) {</b>
<b class="nc"><i>190</i>&nbsp;                        break;</b>
<i>191</i>&nbsp;                    }
<i>192</i>&nbsp;                }
<i>193</i>&nbsp;
<b class="nc"><i>194</i>&nbsp;                final List&lt;String&gt; tk = taxaSets.get(k).asStringList();</b>
<b class="nc"><i>195</i>&nbsp;                final int tkcount = tk.size();</b>
<b class="nc"><i>196</i>&nbsp;                this.xclades[loc] = new int[tkcount];</b>
<b class="nc"><i>197</i>&nbsp;                for (int nt = 0; nt &lt; tkcount; ++nt) {</b>
<b class="nc"><i>198</i>&nbsp;                    final int taxonIndex = getTaxonIndex(tree, tk.get(nt));</b>
<b class="nc"><i>199</i>&nbsp;                    this.xclades[loc][nt] = taxonIndex;</b>
<b class="nc"><i>200</i>&nbsp;                    if (taxonIndex &lt; 0) {</b>
<b class="nc"><i>201</i>&nbsp;                        throw new IllegalArgumentException(&quot;Taxon not found in tree: &quot; + tk.get(nt));</b>
<i>202</i>&nbsp;                    }
<i>203</i>&nbsp;                }
<i>204</i>&nbsp;
<b class="nc"><i>205</i>&nbsp;                orderedCalibrations[loc] = cals.remove(k);</b>
<b class="nc"><i>206</i>&nbsp;                taxaSets.remove(k);</b>
<i>207</i>&nbsp;                // cals and taxaSets should match
<b class="nc"><i>208</i>&nbsp;                --loc;</b>
<b class="nc"><i>209</i>&nbsp;            }</b>
<i>210</i>&nbsp;        }
<i>211</i>&nbsp;
<i>212</i>&nbsp;        // tio[i] will contain all taxaSets contained in the i&#39;th clade, in the form of thier index into orderedCalibrations
<i>213</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc"><i>214</i>&nbsp;		final List&lt;Integer&gt;[] tio = new List[orderedCalibrations.length];</b>
<b class="nc"><i>215</i>&nbsp;        for (int k = 0; k &lt; orderedCalibrations.length; ++k) {</b>
<b class="nc"><i>216</i>&nbsp;            tio[k] = new ArrayList&lt;&gt;();</b>
<i>217</i>&nbsp;        }
<i>218</i>&nbsp;
<b class="nc"><i>219</i>&nbsp;        for (int k = 0; k &lt; orderedCalibrations.length; ++k) {</b>
<b class="nc"><i>220</i>&nbsp;            final TaxonSet txk = orderedCalibrations[k].taxa();</b>
<b class="nc"><i>221</i>&nbsp;            for (int i = k + 1; i &lt; orderedCalibrations.length; ++i) {</b>
<b class="nc"><i>222</i>&nbsp;                if (orderedCalibrations[i].taxa().containsAll(txk)) {</b>
<b class="nc"><i>223</i>&nbsp;                    tio[i].add(k);</b>
<b class="nc"><i>224</i>&nbsp;                    break;</b>
<i>225</i>&nbsp;                }
<i>226</i>&nbsp;            }
<i>227</i>&nbsp;        }
<i>228</i>&nbsp;
<b class="nc"><i>229</i>&nbsp;        this.taxaPartialOrder = new int[orderedCalibrations.length][];</b>
<b class="nc"><i>230</i>&nbsp;        for (int k = 0; k &lt; orderedCalibrations.length; ++k) {</b>
<b class="nc"><i>231</i>&nbsp;            final List&lt;Integer&gt; tiok = tio[k];</b>
<i>232</i>&nbsp;
<b class="nc"><i>233</i>&nbsp;            this.taxaPartialOrder[k] = new int[tiok.size()];</b>
<b class="nc"><i>234</i>&nbsp;            for (int j = 0; j &lt; tiok.size(); ++j) {</b>
<b class="nc"><i>235</i>&nbsp;                this.taxaPartialOrder[k][j] = tiok.get(j);</b>
<i>236</i>&nbsp;            }
<i>237</i>&nbsp;        }
<i>238</i>&nbsp;
<i>239</i>&nbsp;        // true if clade is not contained in any other clade
<b class="nc"><i>240</i>&nbsp;        final boolean[] maximal = new boolean[calCount];</b>
<b class="nc"><i>241</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>242</i>&nbsp;            maximal[k] = true;</b>
<i>243</i>&nbsp;        }
<i>244</i>&nbsp;
<b class="nc"><i>245</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>246</i>&nbsp;            for (final int i : this.taxaPartialOrder[k]) {</b>
<b class="nc"><i>247</i>&nbsp;                maximal[i] = false;</b>
<i>248</i>&nbsp;            }
<i>249</i>&nbsp;        }
<i>250</i>&nbsp;
<b class="nc"><i>251</i>&nbsp;        isYule = deathToBirthRatioInput.get() == null &amp;&amp; sampleProbabilityInput.get() == null;</b>
<i>252</i>&nbsp;
<b class="nc"><i>253</i>&nbsp;        userPDF = userMarInput.get();</b>
<b class="nc"><i>254</i>&nbsp;        if (userPDF == null) {</b>
<b class="nc"><i>255</i>&nbsp;            boolean needTables = false;</b>
<i>256</i>&nbsp;
<b class="nc"><i>257</i>&nbsp;            if (type == Type.OVER_ALL_TOPOS) {</b>
<b class="nc"><i>258</i>&nbsp;                if (calCount == 1 &amp;&amp; isYule ) {</b>
<i>259</i>&nbsp;                    // closed form formula
<i>260</i>&nbsp;                } else {
<b class="nc"><i>261</i>&nbsp;                    boolean anyParent = false;</b>
<b class="nc"><i>262</i>&nbsp;                    for (final CalibrationPoint c : orderedCalibrations) {</b>
<b class="nc"><i>263</i>&nbsp;                        if (c.forParentInput.get()) {</b>
<b class="nc"><i>264</i>&nbsp;                            anyParent = true;</b>
<i>265</i>&nbsp;                        }
<i>266</i>&nbsp;                    }
<b class="nc"><i>267</i>&nbsp;                    if( anyParent ) {</b>
<b class="nc"><i>268</i>&nbsp;                        throw new IllegalArgumentException(&quot;Sorry, not implemented: calibration on parent for more than one clade.&quot;);</b>
<i>269</i>&nbsp;                    }
<b class="nc"><i>270</i>&nbsp;                    if( isYule &amp;&amp;</b>
<b class="nc"><i>271</i>&nbsp;                            calCount == 2 &amp;&amp; orderedCalibrations[1].taxa().containsAll(orderedCalibrations[0].taxa())) {</b>
<i>272</i>&nbsp;                        // closed form formulas
<i>273</i>&nbsp;                    } else {
<b class="nc"><i>274</i>&nbsp;                        needTables = true;</b>
<b class="nc"><i>275</i>&nbsp;                        lastHeights = new double[calCount];</b>
<i>276</i>&nbsp;                    }
<b class="nc"><i>277</i>&nbsp;                }</b>
<b class="nc"><i>278</i>&nbsp;            } else if (type == Type.OVER_RANKED_COUNTS) {</b>
<i>279</i>&nbsp;                //setUpTables(tree.getLeafNodeCount() + 1);
<b class="nc"><i>280</i>&nbsp;                needTables = true;</b>
<i>281</i>&nbsp;            }
<i>282</i>&nbsp;
<b class="nc"><i>283</i>&nbsp;            if( needTables ) {</b>
<b class="nc"><i>284</i>&nbsp;                setUpTables(tree.getLeafNodeCount() + 1);</b>
<b class="nc"><i>285</i>&nbsp;                linsIter = new CalibrationLineagesIterator(this.xclades, this.taxaPartialOrder, maximal,</b>
<b class="nc"><i>286</i>&nbsp;                        tree.getLeafNodeCount());</b>
<i>287</i>&nbsp;            }
<i>288</i>&nbsp;        }
<i>289</i>&nbsp;
<b class="nc"><i>290</i>&nbsp;        final List&lt;Node&gt; leafs = tree.getExternalNodes();</b>
<b class="nc"><i>291</i>&nbsp;        final double height = leafs.get(0).getHeight();</b>
<b class="nc"><i>292</i>&nbsp;        for (final Node leaf : leafs) {</b>
<b class="nc"><i>293</i>&nbsp;        	if (Math.abs(leaf.getHeight() - height) &gt; 1e-8) {</b>
<b class="nc"><i>294</i>&nbsp;        		Log.warning.println(&quot;WARNING: Calibrated Birth-Death Model does not handle dated tips correctly. &quot; +</b>
<i>295</i>&nbsp;                        &quot;Consider using a coalescent prior instead.&quot;);
<b class="nc"><i>296</i>&nbsp;        		break;</b>
<i>297</i>&nbsp;        	}
<b class="nc"><i>298</i>&nbsp;        }</b>
<i>299</i>&nbsp;    }
<i>300</i>&nbsp;
<i>301</i>&nbsp;    Tree compatibleInitialTree() throws MathException {
<b class="nc"><i>302</i>&nbsp;        final int calCount = orderedCalibrations.length;</b>
<b class="nc"><i>303</i>&nbsp;        final double[] lowBound = new double[calCount];</b>
<b class="nc"><i>304</i>&nbsp;        final double[] cladeHeight = new double[calCount];</b>
<i>305</i>&nbsp;
<i>306</i>&nbsp;        // get lower  bound: max(lower bound of dist , bounds of nested clades)
<b class="nc"><i>307</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>308</i>&nbsp;            final CalibrationPoint cal = orderedCalibrations[k];</b>
<b class="nc"><i>309</i>&nbsp;            lowBound[k] = cal.dist().inverseCumulativeProbability(0);</b>
<i>310</i>&nbsp;            // those are node heights
<b class="nc"><i>311</i>&nbsp;            if (lowBound[k] &lt; 0) {</b>
<b class="nc"><i>312</i>&nbsp;                lowBound[k] = 0;</b>
<i>313</i>&nbsp;            }
<b class="nc"><i>314</i>&nbsp;            for (final int i : taxaPartialOrder[k]) {</b>
<b class="nc"><i>315</i>&nbsp;                lowBound[k] = Math.max(lowBound[k], lowBound[i]);</b>
<i>316</i>&nbsp;            }
<b class="nc"><i>317</i>&nbsp;            cladeHeight[k] = cal.dist().inverseCumulativeProbability(1);</b>
<i>318</i>&nbsp;        }
<i>319</i>&nbsp;
<b class="nc"><i>320</i>&nbsp;        for (int k = calCount - 1; k &gt;= 0; --k) {</b>
<i>321</i>&nbsp;            //  cladeHeight[k] should be the upper bound of k
<b class="nc"><i>322</i>&nbsp;            double upper = cladeHeight[k];</b>
<b class="nc"><i>323</i>&nbsp;            if (Double.isInfinite(upper)) {</b>
<b class="nc"><i>324</i>&nbsp;                upper = lowBound[k] + 1;</b>
<i>325</i>&nbsp;            }
<b class="nc"><i>326</i>&nbsp;            cladeHeight[k] = (upper + lowBound[k]) / 2.0;</b>
<i>327</i>&nbsp;
<b class="nc"><i>328</i>&nbsp;            for (final int i : taxaPartialOrder[k]) {</b>
<b class="nc"><i>329</i>&nbsp;                cladeHeight[i] = Math.min(cladeHeight[i], cladeHeight[k]);</b>
<i>330</i>&nbsp;            }
<i>331</i>&nbsp;        }
<i>332</i>&nbsp;
<b class="nc"><i>333</i>&nbsp;        final TreeInterface tree = treeInput.get();</b>
<b class="nc"><i>334</i>&nbsp;        final int nodeCount = tree.getLeafNodeCount();</b>
<b class="nc"><i>335</i>&nbsp;        final boolean[] used = new boolean[nodeCount];</b>
<i>336</i>&nbsp;
<b class="nc"><i>337</i>&nbsp;        int curLeaf = -1;</b>
<b class="nc"><i>338</i>&nbsp;        int curInternal = nodeCount - 1;</b>
<i>339</i>&nbsp;
<b class="nc"><i>340</i>&nbsp;        final Node[] subTree = new Node[calCount];</b>
<b class="nc"><i>341</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>342</i>&nbsp;            final List&lt;Integer&gt; freeTaxa = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>343</i>&nbsp;            for (final int ti : xclades[k]) {</b>
<b class="nc"><i>344</i>&nbsp;                freeTaxa.add(ti);</b>
<i>345</i>&nbsp;            }
<b class="nc"><i>346</i>&nbsp;            for (final int i : taxaPartialOrder[k]) {</b>
<b class="nc"><i>347</i>&nbsp;                for (final int u : xclades[i]) {</b>
<b class="nc"><i>348</i>&nbsp;                    freeTaxa.remove(new Integer(u));</b>
<i>349</i>&nbsp;                }
<i>350</i>&nbsp;            }
<i>351</i>&nbsp;
<b class="nc"><i>352</i>&nbsp;            final List&lt;Node&gt; sbs = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>353</i>&nbsp;            for (final int i : freeTaxa) {</b>
<b class="nc"><i>354</i>&nbsp;                final Node n = new Node(tree.getNode(i).getID());</b>
<b class="nc"><i>355</i>&nbsp;                n.setNr(++curLeaf);</b>
<b class="nc"><i>356</i>&nbsp;                n.setHeight(0.0);</b>
<b class="nc"><i>357</i>&nbsp;                sbs.add(n);</b>
<i>358</i>&nbsp;
<b class="nc"><i>359</i>&nbsp;                used[i] = true;</b>
<b class="nc"><i>360</i>&nbsp;            }</b>
<b class="nc"><i>361</i>&nbsp;            for (final int i : taxaPartialOrder[k]) {</b>
<b class="nc"><i>362</i>&nbsp;                sbs.add(subTree[i]);</b>
<i>363</i>&nbsp;            }
<b class="nc"><i>364</i>&nbsp;            final double base = sbs.get(sbs.size() - 1).getHeight();</b>
<b class="nc"><i>365</i>&nbsp;            final double step = (cladeHeight[k] - base) / (sbs.size() - 1);</b>
<i>366</i>&nbsp;
<b class="nc"><i>367</i>&nbsp;            Node tr = sbs.get(0);</b>
<b class="nc"><i>368</i>&nbsp;            for (int i = 1; i &lt; sbs.size(); ++i) {</b>
<b class="nc"><i>369</i>&nbsp;                tr = Node.connect(tr, sbs.get(i), base + i * step);</b>
<b class="nc"><i>370</i>&nbsp;                tr.setNr(++curInternal);</b>
<i>371</i>&nbsp;            }
<b class="nc"><i>372</i>&nbsp;            subTree[k] = tr;</b>
<i>373</i>&nbsp;        }
<i>374</i>&nbsp;
<b class="nc"><i>375</i>&nbsp;        Node finalTree = subTree[calCount - 1];</b>
<b class="nc"><i>376</i>&nbsp;        double h = cladeHeight[calCount - 1];</b>
<i>377</i>&nbsp;
<b class="nc"><i>378</i>&nbsp;        for(int k = 0; k &lt; calCount-1; ++k) {</b>
<b class="nc"><i>379</i>&nbsp;          final Node s = subTree[k];</b>
<b class="nc"><i>380</i>&nbsp;          h = Math.max(h, cladeHeight[k]) + 1;</b>
<b class="nc"><i>381</i>&nbsp;          finalTree = Node.connect(finalTree, s, h);</b>
<b class="nc"><i>382</i>&nbsp;          finalTree.setNr(++curInternal);</b>
<i>383</i>&nbsp;        }
<i>384</i>&nbsp;
<b class="nc"><i>385</i>&nbsp;        for (int k = 0; k &lt; used.length; ++k) {</b>
<b class="nc"><i>386</i>&nbsp;            if (!used[k]) {</b>
<b class="nc"><i>387</i>&nbsp;                final String tx = tree.getNode(k).getID();</b>
<b class="nc"><i>388</i>&nbsp;                final Node n = new Node(tx);</b>
<b class="nc"><i>389</i>&nbsp;                n.setHeight(0.0);</b>
<b class="nc"><i>390</i>&nbsp;                n.setNr(++curLeaf);</b>
<b class="nc"><i>391</i>&nbsp;                finalTree = Node.connect(finalTree, n, h + 1);</b>
<b class="nc"><i>392</i>&nbsp;                finalTree.setNr(++curInternal);</b>
<b class="nc"><i>393</i>&nbsp;                h += 1;</b>
<i>394</i>&nbsp;            }
<i>395</i>&nbsp;        }
<b class="nc"><i>396</i>&nbsp;        final Tree t = new Tree();</b>
<b class="nc"><i>397</i>&nbsp;        t.setRoot(finalTree);</b>
<b class="nc"><i>398</i>&nbsp;        t.initAndValidate();</b>
<b class="nc"><i>399</i>&nbsp;        return t;</b>
<i>400</i>&nbsp;    }
<i>401</i>&nbsp;
<i>402</i>&nbsp;    @Override
<i>403</i>&nbsp;    public double calculateTreeLogLikelihood(final TreeInterface tree) {
<b class="nc"><i>404</i>&nbsp;        final double lam = birthRateInput.get().getArrayValue();</b>
<i>405</i>&nbsp;
<i>406</i>&nbsp;        double logL;
<b class="nc"><i>407</i>&nbsp;        if( isYule ) {</b>
<b class="nc"><i>408</i>&nbsp;            logL = calculateYuleLikelihood(tree, lam);</b>
<b class="nc"><i>409</i>&nbsp;            logL += getCorrection(tree, lam, 0, 1);</b>
<i>410</i>&nbsp;        } else {
<b class="nc"><i>411</i>&nbsp;            final RealParameter db = deathToBirthRatioInput.get();</b>
<b class="nc"><i>412</i>&nbsp;            final double a = db != null ?  db.getArrayValue() : 0;    assert( a &lt; 1  );</b>
<b class="nc"><i>413</i>&nbsp;            final RealParameter sp = sampleProbabilityInput.get();</b>
<b class="nc"><i>414</i>&nbsp;            final double rho = sp != null ? sp.getArrayValue() : 1;</b>
<b class="nc"><i>415</i>&nbsp;            logL = calculateBDLikelihood(tree, lam, a, rho);</b>
<b class="nc"><i>416</i>&nbsp;            logL += getCorrection(tree, lam, a, rho);</b>
<i>417</i>&nbsp;        }
<i>418</i>&nbsp;        //final double mar = getCorrection(tree, lam);
<i>419</i>&nbsp;       // logL += mar;
<b class="nc"><i>420</i>&nbsp;        return logL;</b>
<i>421</i>&nbsp;    }
<i>422</i>&nbsp;
<i>423</i>&nbsp;    private double calculateBDLikelihood(final TreeInterface tree, final double r, final double a, final double rho) {
<b class="nc"><i>424</i>&nbsp;        if( a == 0 &amp;&amp; rho == 1.0 ) {</b>
<b class="nc"><i>425</i>&nbsp;            return calculateYuleLikelihood(tree, r);</b>
<i>426</i>&nbsp;        }
<i>427</i>&nbsp;
<b class="nc"><i>428</i>&nbsp;        final int taxonCount = tree.getLeafNodeCount();</b>
<i>429</i>&nbsp;
<i>430</i>&nbsp;        // add all lambda multipliers here
<b class="nc"><i>431</i>&nbsp;        double logL = lfactorials[taxonCount] + (taxonCount - 1) * Math.log(r * rho);</b>
<b class="nc"><i>432</i>&nbsp;        final Node[] nodes = tree.getNodesAsArray();</b>
<i>433</i>&nbsp;
<b class="nc"><i>434</i>&nbsp;        logL += taxonCount * Math.log(1 - a);</b>
<i>435</i>&nbsp;
<b class="nc"><i>436</i>&nbsp;        for (int i = taxonCount; i &lt; nodes.length; i++) {</b>
<b class="nc"><i>437</i>&nbsp;            final Node node = nodes[i];                   assert (!node.isLeaf());</b>
<b class="nc"><i>438</i>&nbsp;            final double height = node.getHeight();</b>
<b class="nc"><i>439</i>&nbsp;            final double mrh = -r * height;</b>
<b class="nc"><i>440</i>&nbsp;            final double z = Math.log(rho + ((1-rho) - a) * Math.exp(mrh));</b>
<b class="nc"><i>441</i>&nbsp;            double l = -2 * z + mrh;</b>
<b class="nc"><i>442</i>&nbsp;            if( node.isRoot() ) {</b>
<b class="nc"><i>443</i>&nbsp;                l += mrh - z;</b>
<i>444</i>&nbsp;            }
<b class="nc"><i>445</i>&nbsp;            logL += l;</b>
<i>446</i>&nbsp;        }
<i>447</i>&nbsp;
<b class="nc"><i>448</i>&nbsp;        return logL;</b>
<i>449</i>&nbsp;    }
<i>450</i>&nbsp;
<i>451</i>&nbsp;    private static double calculateYuleLikelihood(final TreeInterface tree, final double lam) {
<b class="nc"><i>452</i>&nbsp;        final int taxonCount = tree.getLeafNodeCount();</b>
<i>453</i>&nbsp;
<i>454</i>&nbsp;        // add all lambda multipliers here
<i>455</i>&nbsp;        // No normalization at the moment.  for n! use logGamma(taxonCount + 1);
<b class="nc"><i>456</i>&nbsp;        double logL = (taxonCount - 1) * Math.log(lam);</b>
<i>457</i>&nbsp;
<b class="nc"><i>458</i>&nbsp;        final Node[] nodes = tree.getNodesAsArray();</b>
<b class="nc"><i>459</i>&nbsp;        for (int i = taxonCount; i &lt; nodes.length; i++) {</b>
<b class="nc"><i>460</i>&nbsp;            final Node node = nodes[i];                     assert (!node.isLeaf());</b>
<b class="nc"><i>461</i>&nbsp;            final double height = node.getHeight();</b>
<b class="nc"><i>462</i>&nbsp;            final double mrh = -lam * height;</b>
<b class="nc"><i>463</i>&nbsp;            logL += mrh + (node.isRoot() ? mrh : 0);</b>
<i>464</i>&nbsp;        }
<b class="nc"><i>465</i>&nbsp;        return logL;</b>
<i>466</i>&nbsp;    }
<i>467</i>&nbsp;
<i>468</i>&nbsp;    public double getCorrection(final TreeInterface tree, final double lam, final double a, final double rho) {
<b class="nc"><i>469</i>&nbsp;        double logL = 0.0;</b>
<i>470</i>&nbsp;
<b class="nc"><i>471</i>&nbsp;        final int calCount = orderedCalibrations.length;</b>
<b class="nc"><i>472</i>&nbsp;        final double[] hs = new double[calCount];</b>
<i>473</i>&nbsp;
<b class="nc"><i>474</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>475</i>&nbsp;            final CalibrationPoint cal = orderedCalibrations[k];</b>
<i>476</i>&nbsp;            Node c;
<b class="nc"><i>477</i>&nbsp;            final int[] taxk = xclades[k];</b>
<b class="nc"><i>478</i>&nbsp;            if (taxk.length &gt; 1) {</b>
<i>479</i>&nbsp;                //  find MRCA of taxa
<b class="nc"><i>480</i>&nbsp;                c = getCommonAncestor(tree, taxk);</b>
<i>481</i>&nbsp;
<i>482</i>&nbsp;                // only monophyletics clades can be calibrated
<b class="nc"><i>483</i>&nbsp;                if (getLeafCount(c) != taxk.length) {</b>
<b class="nc"><i>484</i>&nbsp;                    return Double.NEGATIVE_INFINITY;</b>
<i>485</i>&nbsp;                }
<i>486</i>&nbsp;            } else {
<b class="nc"><i>487</i>&nbsp;                c = tree.getNode(taxk[0]);</b>
<b class="nc"><i>488</i>&nbsp;                assert cal.forParent();</b>
<i>489</i>&nbsp;            }
<i>490</i>&nbsp;
<b class="nc"><i>491</i>&nbsp;            if (cal.forParent()) {</b>
<b class="nc"><i>492</i>&nbsp;                c = c.getParent();</b>
<i>493</i>&nbsp;            }
<i>494</i>&nbsp;
<b class="nc"><i>495</i>&nbsp;            final double h = c.getHeight();</b>
<i>496</i>&nbsp;            // add calibration density for point
<b class="nc"><i>497</i>&nbsp;            if (calcCalibrations) {</b>
<b class="nc"><i>498</i>&nbsp;                logL += cal.logPdf(h);</b>
<i>499</i>&nbsp;            }
<i>500</i>&nbsp;
<b class="nc"><i>501</i>&nbsp;            hs[k] = h;</b>
<i>502</i>&nbsp;        }
<i>503</i>&nbsp;
<b class="nc"><i>504</i>&nbsp;        if (Double.isInfinite(logL)) {</b>
<i>505</i>&nbsp;            // some calibration points out of range
<b class="nc"><i>506</i>&nbsp;            return logL;</b>
<i>507</i>&nbsp;        }
<i>508</i>&nbsp;
<b class="nc"><i>509</i>&nbsp;        if (type == Type.NONE) {</b>
<b class="nc"><i>510</i>&nbsp;            return logL;</b>
<i>511</i>&nbsp;        }
<i>512</i>&nbsp;
<b class="nc"><i>513</i>&nbsp;        if (userPDF == null) {</b>
<b class="nc"><i>514</i>&nbsp;            final int taxonCount = tree.getLeafNodeCount();</b>
<b class="nc"><i>515</i>&nbsp;            switch (type) {</b>
<i>516</i>&nbsp;                case OVER_ALL_TOPOS: {
<b class="nc"><i>517</i>&nbsp;                    if (calCount == 1 &amp;&amp; isYule ) {</b>
<b class="nc"><i>518</i>&nbsp;                        logL -= logMarginalDensity(lam, taxonCount, hs[0], xclades[0].length,</b>
<b class="nc"><i>519</i>&nbsp;                                orderedCalibrations[0].forParent());</b>
<b class="nc"><i>520</i>&nbsp;                    } else if (calCount == 2 &amp;&amp; taxaPartialOrder[1].length == 1 &amp;&amp; isYule) {</b>
<i>521</i>&nbsp;                        //assert !forParent[0] &amp;&amp; !forParent[1];
<b class="nc"><i>522</i>&nbsp;                        logL -= logMarginalDensity(lam, taxonCount, hs[0], xclades[0].length,</b>
<i>523</i>&nbsp;                                hs[1], xclades[1].length);
<i>524</i>&nbsp;                    } else {
<i>525</i>&nbsp;
<b class="nc"><i>526</i>&nbsp;                        if (lastLam == lam) {</b>
<b class="nc"><i>527</i>&nbsp;                            int k = 0;</b>
<b class="nc"><i>528</i>&nbsp;                            for (; k &lt; hs.length; ++k) {</b>
<b class="nc"><i>529</i>&nbsp;                                if (hs[k] != lastHeights[k]) {</b>
<b class="nc"><i>530</i>&nbsp;                                    break;</b>
<i>531</i>&nbsp;                                }
<i>532</i>&nbsp;                            }
<b class="nc"><i>533</i>&nbsp;                            if (k == hs.length) {</b>
<b class="nc"><i>534</i>&nbsp;                                return lastValue;</b>
<i>535</i>&nbsp;                            }
<i>536</i>&nbsp;                        }
<i>537</i>&nbsp;
<i>538</i>&nbsp;                        // the slow and painful way
<b class="nc"><i>539</i>&nbsp;                        final double[] hss = new double[hs.length];</b>
<b class="nc"><i>540</i>&nbsp;                        final int[] ranks = new int[hs.length];</b>
<b class="nc"><i>541</i>&nbsp;                        for (int k = 0; k &lt; hs.length; ++k) {</b>
<b class="nc"><i>542</i>&nbsp;                            int r = 0;</b>
<b class="nc"><i>543</i>&nbsp;                            for(int j = 0; j &lt; k; ++j) {</b>
<b class="nc"><i>544</i>&nbsp;                              r += (hs[j] &lt;= hs[k]) ? 1 : 0;</b>
<i>545</i>&nbsp;                            }
<b class="nc"><i>546</i>&nbsp;                            for(int j = k+1; j &lt; hs.length; ++j) {</b>
<b class="nc"><i>547</i>&nbsp;                              r += (hs[j] &lt; hs[k]) ? 1 : 0;</b>
<i>548</i>&nbsp;                            }
<i>549</i>&nbsp;//                            for (final double h : hs) {
<i>550</i>&nbsp;//                                r += (h &lt; hs[k]) ? 1 : 0;
<i>551</i>&nbsp;//                            }
<b class="nc"><i>552</i>&nbsp;                            ranks[k] = r + 1;</b>
<b class="nc"><i>553</i>&nbsp;                            hss[r] = hs[k];</b>
<i>554</i>&nbsp;                        }
<b class="nc"><i>555</i>&nbsp;                        logL -= logMarginalDensity(lam, hss, ranks, linsIter);</b>
<i>556</i>&nbsp;
<b class="nc"><i>557</i>&nbsp;                        lastLam = lam;</b>
<b class="nc"><i>558</i>&nbsp;                        System.arraycopy(hs, 0, lastHeights, 0, lastHeights.length);</b>
<b class="nc"><i>559</i>&nbsp;                        lastValue = logL;</b>
<i>560</i>&nbsp;                    }
<b class="nc"><i>561</i>&nbsp;                    break;</b>
<i>562</i>&nbsp;                }
<i>563</i>&nbsp;
<i>564</i>&nbsp;                case OVER_RANKED_COUNTS: {
<b class="nc"><i>565</i>&nbsp;                    final int[] ranks = new int[hs.length];</b>
<b class="nc"><i>566</i>&nbsp;                    for (int k = 0; k &lt; hs.length; ++k) {</b>
<b class="nc"><i>567</i>&nbsp;                        int r = 0;</b>
<b class="nc"><i>568</i>&nbsp;                        for(int j = 0; j &lt; k; ++j) {</b>
<b class="nc"><i>569</i>&nbsp;                            r += (hs[j] &lt;= hs[k]) ? 1 : 0;</b>
<i>570</i>&nbsp;                        }
<b class="nc"><i>571</i>&nbsp;                        for(int j = k+1; j &lt; hs.length; ++j) {</b>
<b class="nc"><i>572</i>&nbsp;                            r += (hs[j] &lt; hs[k]) ? 1 : 0;</b>
<i>573</i>&nbsp;                        }
<b class="nc"><i>574</i>&nbsp;                        ranks[k] = r + 1;</b>
<i>575</i>&nbsp;                    }
<b class="nc"><i>576</i>&nbsp;                    final double nt = countTrees(ranks, linsIter);</b>
<b class="nc"><i>577</i>&nbsp;                    logL -= nt;</b>
<i>578</i>&nbsp;
<b class="nc"><i>579</i>&nbsp;                    Arrays.sort(hs);</b>
<b class="nc"><i>580</i>&nbsp;                    final int[] cs = new int[calCount + 1];</b>
<b class="nc"><i>581</i>&nbsp;                    for (final Node n : tree.getInternalNodes()) {</b>
<b class="nc"><i>582</i>&nbsp;                        final double nhk = n.getHeight();</b>
<b class="nc"><i>583</i>&nbsp;                        int i = 0;</b>
<b class="nc"><i>584</i>&nbsp;                        for (/**/; i &lt; hs.length; ++i) {</b>
<b class="nc"><i>585</i>&nbsp;                            if (hs[i] &gt;= nhk) {</b>
<b class="nc"><i>586</i>&nbsp;                                break;</b>
<i>587</i>&nbsp;                            }
<i>588</i>&nbsp;                        }
<b class="nc"><i>589</i>&nbsp;                        if (i == hs.length) {</b>
<b class="nc"><i>590</i>&nbsp;                            cs[i]++;</b>
<i>591</i>&nbsp;                        } else {
<b class="nc"><i>592</i>&nbsp;                            if (nhk &lt; hs[i]) {</b>
<b class="nc"><i>593</i>&nbsp;                                cs[i]++;</b>
<i>594</i>&nbsp;                            }
<i>595</i>&nbsp;                        }
<b class="nc"><i>596</i>&nbsp;                    }</b>
<i>597</i>&nbsp;
<b class="nc"><i>598</i>&nbsp;                    if( isYule ) {</b>
<b class="nc"><i>599</i>&nbsp;                        double ll = 0;</b>
<i>600</i>&nbsp;
<b class="nc"><i>601</i>&nbsp;                        ll += cs[0] * Math.log1p(-Math.exp(-lam * hs[0])) - lam * hs[0] - lfactorials[cs[0]];</b>
<b class="nc"><i>602</i>&nbsp;                        for (int i = 1; i &lt; cs.length - 1; ++i) {</b>
<b class="nc"><i>603</i>&nbsp;                            final int c = cs[i];</b>
<b class="nc"><i>604</i>&nbsp;                            ll += c * (Math.log1p(-Math.exp(-lam * (hs[i] - hs[i - 1]))) - lam * hs[i - 1]);</b>
<b class="nc"><i>605</i>&nbsp;                            ll += -lam * hs[i] - lfactorials[c];</b>
<i>606</i>&nbsp;                        }
<b class="nc"><i>607</i>&nbsp;                        ll += -lam * (cs[calCount] + 1) * hs[calCount - 1] - lfactorials[cs[calCount] + 1];</b>
<b class="nc"><i>608</i>&nbsp;                        ll += Math.log(lam) * calCount;</b>
<i>609</i>&nbsp;
<b class="nc"><i>610</i>&nbsp;                        logL -= ll;</b>
<b class="nc"><i>611</i>&nbsp;                    } else {</b>
<b class="nc"><i>612</i>&nbsp;                        assert( a &lt; 1 );</b>
<i>613</i>&nbsp;                        // We try to minimize the effects of numerical unstability,
<i>614</i>&nbsp;                        // so the evaluations look different than the nice equations in the MS.
<i>615</i>&nbsp;
<b class="nc"><i>616</i>&nbsp;                        final double r = lam;</b>
<i>617</i>&nbsp;
<b class="nc"><i>618</i>&nbsp;                        final double ia = 1 - a;</b>
<b class="nc"><i>619</i>&nbsp;                        final double ira = ia-rho;</b>
<b class="nc"><i>620</i>&nbsp;                        final double v = (ia*ia)/r;</b>
<i>621</i>&nbsp;
<i>622</i>&nbsp;                        // accumulate terms here
<b class="nc"><i>623</i>&nbsp;                        double ll = 0;</b>
<b class="nc"><i>624</i>&nbsp;                        for (int i = 0; i &lt; cs.length - 1; ++i) {</b>
<b class="nc"><i>625</i>&nbsp;                            final int c = cs[i];</b>
<b class="nc"><i>626</i>&nbsp;                            final double mrh = -r * hs[i];</b>
<b class="nc"><i>627</i>&nbsp;                            final double mrh1 = (i&gt;0) ? -r * hs[i-1] : 0;</b>
<i>628</i>&nbsp;
<b class="nc"><i>629</i>&nbsp;                            ll -= lfactorials[c];</b>
<i>630</i>&nbsp;                            //double xx =  Math.log(1 - Math.exp(mrh - mrh1));
<i>631</i>&nbsp;                            // can we have accurate  log(1+e^x) ??
<b class="nc"><i>632</i>&nbsp;                            final double xxo = Math.log1p(-Math.exp(mrh - mrh1));</b>
<i>633</i>&nbsp;
<b class="nc"><i>634</i>&nbsp;                            final double xx1 = rho + ira*Math.exp(mrh);</b>
<b class="nc"><i>635</i>&nbsp;                            final double xx2 = rho + ira*Math.exp(mrh1);</b>
<b class="nc"><i>636</i>&nbsp;                            ll += c * (mrh1 + xxo + Math.log(v/(xx1*xx2)));</b>
<i>637</i>&nbsp;
<i>638</i>&nbsp;                            // contribution of  calibration point
<i>639</i>&nbsp;
<b class="nc"><i>640</i>&nbsp;                            final double z = Math.log(ia / (rho + ira * Math.exp(mrh)));</b>
<b class="nc"><i>641</i>&nbsp;                            ll += 2 * z + mrh;</b>
<i>642</i>&nbsp;                        }
<i>643</i>&nbsp;
<i>644</i>&nbsp;                        // from last calibration to oo contribution
<b class="nc"><i>645</i>&nbsp;                        final double xu = ia/(rho + ira * Math.exp(-r*hs[calCount - 1]));</b>
<b class="nc"><i>646</i>&nbsp;                        final int n2 = cs[calCount];                 assert n2 &gt; 0;  // fixme</b>
<i>647</i>&nbsp;
<b class="nc"><i>648</i>&nbsp;                        final double rhoia = rho / ia;</b>
<b class="nc"><i>649</i>&nbsp;                        ll += -lfactorials[n2 + 1] - (n2) * Math.log(r * rhoia)</b>
<b class="nc"><i>650</i>&nbsp;                                - (n2+1) * r * hs[calCount - 1] + (n2+1) * Math.log(xu);</b>
<i>651</i>&nbsp;                        // non-node terms
<b class="nc"><i>652</i>&nbsp;                        ll += lfactorials[taxonCount] + (taxonCount - 1) * Math.log(r*rhoia);</b>
<b class="nc"><i>653</i>&nbsp;                        logL -= ll;</b>
<i>654</i>&nbsp;                    }
<b class="nc"><i>655</i>&nbsp;                    break;</b>
<i>656</i>&nbsp;                }
<i>657</i>&nbsp;			default:
<i>658</i>&nbsp;				break;
<i>659</i>&nbsp;            }
<b class="nc"><i>660</i>&nbsp;        } else {</b>
<b class="nc"><i>661</i>&nbsp;            final double value = userPDF.getArrayValue();</b>
<b class="nc"><i>662</i>&nbsp;            if (Double.isNaN(value) || Double.isInfinite(value)) {</b>
<b class="nc"><i>663</i>&nbsp;                logL = Double.NEGATIVE_INFINITY;</b>
<i>664</i>&nbsp;            } else {
<b class="nc"><i>665</i>&nbsp;                logL -= value;</b>
<i>666</i>&nbsp;            }
<i>667</i>&nbsp;        }
<b class="nc"><i>668</i>&nbsp;        return logL;</b>
<i>669</i>&nbsp;    }
<i>670</i>&nbsp;
<i>671</i>&nbsp;    private static double logMarginalDensity(final double lam, final int taxonCount, final double h, final int clade,
<i>672</i>&nbsp;                                             final boolean forParent) {
<i>673</i>&nbsp;        double lgp;
<i>674</i>&nbsp;
<b class="nc"><i>675</i>&nbsp;        final double lh = lam * h;</b>
<i>676</i>&nbsp;
<b class="nc"><i>677</i>&nbsp;        if (forParent) {</b>
<i>678</i>&nbsp;            // n(n+1) factor left out
<i>679</i>&nbsp;
<b class="nc"><i>680</i>&nbsp;            lgp = -2 * lh + Math.log(lam);</b>
<b class="nc"><i>681</i>&nbsp;            if (clade &gt; 1) {</b>
<b class="nc"><i>682</i>&nbsp;                lgp += (clade - 1) * Math.log(1 - Math.exp(-lh));</b>
<i>683</i>&nbsp;            }
<i>684</i>&nbsp;        } else {
<b class="nc"><i>685</i>&nbsp;            assert clade &gt; 1;</b>
<i>686</i>&nbsp;
<b class="nc"><i>687</i>&nbsp;            lgp = -3 * lh + (clade - 2) * Math.log(1 - Math.exp(-lh)) + Math.log(lam);</b>
<i>688</i>&nbsp;
<i>689</i>&nbsp;            // root is a special case
<b class="nc"><i>690</i>&nbsp;            if (taxonCount == clade) {</b>
<i>691</i>&nbsp;                // n(n-1) factor left out
<b class="nc"><i>692</i>&nbsp;                lgp += lh;</b>
<i>693</i>&nbsp;            } else {
<i>694</i>&nbsp;                // (n^3-n)/2 factor left out
<i>695</i>&nbsp;            }
<i>696</i>&nbsp;        }
<i>697</i>&nbsp;
<b class="nc"><i>698</i>&nbsp;        return lgp;</b>
<i>699</i>&nbsp;    }
<i>700</i>&nbsp;
<i>701</i>&nbsp;    private static double logMarginalDensity(final double lam, final int taxonCount, final double h2, final int n,
<i>702</i>&nbsp;                                             final double h1, final int nm) {
<i>703</i>&nbsp;
<b class="nc"><i>704</i>&nbsp;        assert h2 &lt;= h1 &amp;&amp; n &lt; nm;</b>
<i>705</i>&nbsp;
<b class="nc"><i>706</i>&nbsp;        final int m = nm - n;</b>
<i>707</i>&nbsp;
<b class="nc"><i>708</i>&nbsp;        final double elh2 = Math.exp(-lam * h2);</b>
<b class="nc"><i>709</i>&nbsp;        final double elh1 = Math.exp(-lam * h1);</b>
<i>710</i>&nbsp;
<b class="nc"><i>711</i>&nbsp;        double lgl = 2 * Math.log(lam);</b>
<i>712</i>&nbsp;
<b class="nc"><i>713</i>&nbsp;        lgl += (n - 2) * Math.log(1 - elh2);</b>
<b class="nc"><i>714</i>&nbsp;        lgl += (m - 3) * Math.log(1 - elh1);</b>
<i>715</i>&nbsp;
<b class="nc"><i>716</i>&nbsp;        lgl += Math.log(1 - 2 * m * elh1 + 2 * (m - 1) * elh2</b>
<i>717</i>&nbsp;                - m * (m - 1) * elh1 * elh2 + (m * (m + 1) / 2.) * elh1 * elh1
<i>718</i>&nbsp;                + ((m - 1) * (m - 2) / 2.) * elh2 * elh2);
<i>719</i>&nbsp;
<b class="nc"><i>720</i>&nbsp;        if (nm &lt; taxonCount) {</b>
<i>721</i>&nbsp;            /* lgl += Math.log(0.5*(n*(n*n-1))*(n+1+m)) */
<b class="nc"><i>722</i>&nbsp;            lgl -= lam * (h2 + 3 * h1);</b>
<i>723</i>&nbsp;        } else {
<i>724</i>&nbsp;            /* lgl += Math.log(lam) /* + Math.log(n*(n*n-1)) */
<b class="nc"><i>725</i>&nbsp;            lgl -= lam * (h2 + 2 * h1);</b>
<i>726</i>&nbsp;        }
<i>727</i>&nbsp;
<b class="nc"><i>728</i>&nbsp;        return lgl;</b>
<i>729</i>&nbsp;    }
<i>730</i>&nbsp;
<i>731</i>&nbsp;    private double logMarginalDensity(final double lam, final double[] hs, final int[] ranks,
<i>732</i>&nbsp;                                      final CalibrationLineagesIterator cli) {
<i>733</i>&nbsp;
<b class="nc"><i>734</i>&nbsp;        final int ni = cli.setup(ranks);</b>
<i>735</i>&nbsp;
<b class="nc"><i>736</i>&nbsp;        final int heights = hs.length;</b>
<i>737</i>&nbsp;
<b class="nc"><i>738</i>&nbsp;        final double[] lehs = new double[heights + 1];</b>
<b class="nc"><i>739</i>&nbsp;        lehs[0] = 0.0;</b>
<b class="nc"><i>740</i>&nbsp;        for (int i = 1; i &lt; lehs.length; ++i) {</b>
<b class="nc"><i>741</i>&nbsp;            lehs[i] = -lam * hs[i - 1];</b>
<i>742</i>&nbsp;        }
<i>743</i>&nbsp;
<i>744</i>&nbsp;        // assert maxRank == len(sit)
<i>745</i>&nbsp;        //final boolean noRoot = ni == lehs.length;
<b class="nc"><i>746</i>&nbsp;        final boolean noRoot = ! cli.isRootCalibrated();</b>
<i>747</i>&nbsp;
<b class="nc"><i>748</i>&nbsp;        final int levels = heights + (noRoot ? 1 : 0);</b>
<i>749</i>&nbsp;
<b class="nc"><i>750</i>&nbsp;        final double[] lebase = new double[levels];</b>
<i>751</i>&nbsp;
<b class="nc"><i>752</i>&nbsp;        for (int i = 0; i &lt; heights; ++i) {</b>
<b class="nc"><i>753</i>&nbsp;            final double d = lehs[i + 1] - lehs[i];</b>
<b class="nc"><i>754</i>&nbsp;            lebase[i] = d != 0 ? lehs[i] + Math.log1p(-Math.exp(d)) : -50;</b>
<i>755</i>&nbsp;        }
<i>756</i>&nbsp;
<b class="nc"><i>757</i>&nbsp;        if (noRoot) {</b>
<b class="nc"><i>758</i>&nbsp;            lebase[heights] = lehs[heights];</b>
<i>759</i>&nbsp;        }
<i>760</i>&nbsp;
<b class="nc"><i>761</i>&nbsp;        final int[] linsAtLevel = new int[levels];</b>
<i>762</i>&nbsp;
<b class="nc"><i>763</i>&nbsp;        final int[][] joiners = cli.allJoiners();</b>
<i>764</i>&nbsp;
<b class="nc"><i>765</i>&nbsp;        double val = 0;</b>
<b class="nc"><i>766</i>&nbsp;        boolean first = true;</b>
<i>767</i>&nbsp;
<i>768</i>&nbsp;        int[][] linsInLevels;
<i>769</i>&nbsp;        //int ccc = 0;
<b class="nc"><i>770</i>&nbsp;        while ((linsInLevels = cli.next()) != null) {</b>
<i>771</i>&nbsp;            //ccc++;
<b class="nc"><i>772</i>&nbsp;            double v = countRankedTrees(levels, linsInLevels, joiners, linsAtLevel);</b>
<i>773</i>&nbsp;            // 1 for root formula, 1 for kludge in iterator which sets root as 2 lineages
<b class="nc"><i>774</i>&nbsp;            if (noRoot) {</b>
<b class="nc"><i>775</i>&nbsp;                final int ll = linsAtLevel[levels - 1] + 2;</b>
<b class="nc"><i>776</i>&nbsp;                linsAtLevel[levels - 1] = ll;</b>
<i>777</i>&nbsp;
<b class="nc"><i>778</i>&nbsp;                v -= lc2[ll] + lg2;</b>
<i>779</i>&nbsp;            }
<i>780</i>&nbsp;
<b class="nc"><i>781</i>&nbsp;            for (int i = 0; i &lt; levels; ++i) {</b>
<b class="nc"><i>782</i>&nbsp;                v += linsAtLevel[i] * lebase[i];</b>
<i>783</i>&nbsp;            }
<i>784</i>&nbsp;
<b class="nc"><i>785</i>&nbsp;            if (first) {</b>
<b class="nc"><i>786</i>&nbsp;                val = v;</b>
<b class="nc"><i>787</i>&nbsp;                first = false;</b>
<i>788</i>&nbsp;            } else {
<b class="nc"><i>789</i>&nbsp;                if (val &gt; v) {</b>
<b class="nc"><i>790</i>&nbsp;                    val += Math.log1p(Math.exp(v - val));</b>
<i>791</i>&nbsp;                } else {
<b class="nc"><i>792</i>&nbsp;                    val = v + Math.log1p(Math.exp(val - v));</b>
<i>793</i>&nbsp;                }
<i>794</i>&nbsp;            }
<b class="nc"><i>795</i>&nbsp;        }</b>
<i>796</i>&nbsp;
<b class="nc"><i>797</i>&nbsp;        double logc0 = 0.0;</b>
<b class="nc"><i>798</i>&nbsp;        int totLin = 0;</b>
<b class="nc"><i>799</i>&nbsp;        for (int i = 0; i &lt; ni; ++i) {</b>
<b class="nc"><i>800</i>&nbsp;            final int l = cli.start(i);</b>
<b class="nc"><i>801</i>&nbsp;            if (l &gt; 0) {</b>
<b class="nc"><i>802</i>&nbsp;                logc0 += lNR[l];</b>
<b class="nc"><i>803</i>&nbsp;                totLin += l;</b>
<i>804</i>&nbsp;            }
<i>805</i>&nbsp;        }
<i>806</i>&nbsp;
<b class="nc"><i>807</i>&nbsp;        final double logc1 = lfactorials[totLin];</b>
<i>808</i>&nbsp;
<b class="nc"><i>809</i>&nbsp;        double logc2 = heights * Math.log(lam);</b>
<i>810</i>&nbsp;
<b class="nc"><i>811</i>&nbsp;        for (int i = 1; i &lt; heights + 1; ++i) {</b>
<b class="nc"><i>812</i>&nbsp;            logc2 += lehs[i];</b>
<i>813</i>&nbsp;        }
<i>814</i>&nbsp;
<b class="nc"><i>815</i>&nbsp;        if (!noRoot) {</b>
<i>816</i>&nbsp;            // we don&#39;t have an iterator for 0 free lineages
<b class="nc"><i>817</i>&nbsp;            logc2 += 1 * lehs[heights];</b>
<i>818</i>&nbsp;        }
<i>819</i>&nbsp;
<i>820</i>&nbsp;        // Missing scale by total of all possible trees over all ranking orders.
<i>821</i>&nbsp;        // Add it outside if needed for comparison.
<i>822</i>&nbsp;
<b class="nc"><i>823</i>&nbsp;        val += logc0 + logc1 + logc2;</b>
<i>824</i>&nbsp;
<b class="nc"><i>825</i>&nbsp;        return val;</b>
<i>826</i>&nbsp;    }
<i>827</i>&nbsp;
<i>828</i>&nbsp;    // should cache those for (say) up to 6 (6!=720) values. need rank permutation to index function
<i>829</i>&nbsp;    //
<i>830</i>&nbsp;    private double countTrees(final int[] ranks, final CalibrationLineagesIterator cli) {
<b class="nc"><i>831</i>&nbsp;        final int ni = cli.setup(ranks);</b>
<b class="nc"><i>832</i>&nbsp;        final boolean noRoot = ! cli.isRootCalibrated();</b>
<i>833</i>&nbsp;
<b class="nc"><i>834</i>&nbsp;        final int[] linsAtLevel = new int[ni];</b>
<i>835</i>&nbsp;
<b class="nc"><i>836</i>&nbsp;        final int[][] joiners = cli.allJoiners();</b>
<i>837</i>&nbsp;
<b class="nc"><i>838</i>&nbsp;        double val = 0;</b>
<b class="nc"><i>839</i>&nbsp;        boolean first = true;</b>
<i>840</i>&nbsp;        int[][] linsInLevels;
<i>841</i>&nbsp;
<b class="nc"><i>842</i>&nbsp;        while ((linsInLevels = cli.next()) != null) {</b>
<b class="nc"><i>843</i>&nbsp;            double v = countRankedTrees(ni, linsInLevels, joiners, linsAtLevel);</b>
<i>844</i>&nbsp;            // 1 for root formula, 1 for kludge in iterator which sets root as 2 lineages
<b class="nc"><i>845</i>&nbsp;            if (noRoot) {</b>
<b class="nc"><i>846</i>&nbsp;                final int ll = linsAtLevel[ni - 1] + 2;</b>
<b class="nc"><i>847</i>&nbsp;                v -= lc2[ll] + lg2;</b>
<i>848</i>&nbsp;            }
<b class="nc"><i>849</i>&nbsp;            if (first) {</b>
<b class="nc"><i>850</i>&nbsp;                val = v;</b>
<b class="nc"><i>851</i>&nbsp;                first = false;</b>
<i>852</i>&nbsp;            } else {
<b class="nc"><i>853</i>&nbsp;                if (val &gt; v) {</b>
<b class="nc"><i>854</i>&nbsp;                    val += Math.log1p(Math.exp(v - val));</b>
<i>855</i>&nbsp;                } else {
<b class="nc"><i>856</i>&nbsp;                    val = v + Math.log1p(Math.exp(val - v));</b>
<i>857</i>&nbsp;                }
<i>858</i>&nbsp;            }
<b class="nc"><i>859</i>&nbsp;        }</b>
<b class="nc"><i>860</i>&nbsp;        return val;</b>
<i>861</i>&nbsp;    }
<i>862</i>&nbsp;
<i>863</i>&nbsp;    private double
<i>864</i>&nbsp;    countRankedTrees(final int levels, final int[][] linsAtCrossings, final int[][] joiners, final int[] linsAtLevel) {
<b class="nc"><i>865</i>&nbsp;        double logCount = 0;</b>
<i>866</i>&nbsp;
<b class="nc"><i>867</i>&nbsp;        for (int i = 0; i &lt; levels; ++i) {</b>
<b class="nc"><i>868</i>&nbsp;            int sumLins = 0;</b>
<b class="nc"><i>869</i>&nbsp;            for (int k = i; k &lt; levels; ++k) {</b>
<b class="nc"><i>870</i>&nbsp;                final int[] lack = linsAtCrossings[k];</b>
<b class="nc"><i>871</i>&nbsp;                int cki = lack[i];</b>
<b class="nc"><i>872</i>&nbsp;                if (joiners[k][i] &gt; 0) {</b>
<b class="nc"><i>873</i>&nbsp;                    ++cki;</b>
<b class="nc"><i>874</i>&nbsp;                    if (cki &gt; 1) {</b>
<i>875</i>&nbsp;                        // can be 1 if iterator without lins - for joiners only - need to check this is correct
<b class="nc"><i>876</i>&nbsp;                        logCount += lc2[cki];</b>
<i>877</i>&nbsp;                    } //assert(cki &gt;= 2);
<i>878</i>&nbsp;                }
<b class="nc"><i>879</i>&nbsp;                final int l = cki - lack[i + 1];   //assert(l &gt;= 0);</b>
<b class="nc"><i>880</i>&nbsp;                logCount -= lfactorials[l];</b>
<b class="nc"><i>881</i>&nbsp;                sumLins += l;</b>
<i>882</i>&nbsp;            }
<b class="nc"><i>883</i>&nbsp;            linsAtLevel[i] = sumLins;</b>
<i>884</i>&nbsp;        }
<i>885</i>&nbsp;
<b class="nc"><i>886</i>&nbsp;        return logCount;</b>
<i>887</i>&nbsp;    }
<i>888</i>&nbsp;
<b class="nc"><i>889</i>&nbsp;    private CalibrationLineagesIterator linsIter = null;</b>
<i>890</i>&nbsp;
<b class="nc"><i>891</i>&nbsp;    double lastLam = Double.NEGATIVE_INFINITY;</b>
<i>892</i>&nbsp;    double[] lastHeights;
<b class="nc"><i>893</i>&nbsp;    double lastValue = Double.NEGATIVE_INFINITY;</b>
<i>894</i>&nbsp;
<i>895</i>&nbsp;    // speedup constants
<b class="nc"><i>896</i>&nbsp;    private final double lg2 = Math.log(2.0);</b>
<i>897</i>&nbsp;    private double[] lc2;
<i>898</i>&nbsp;    private double[] lNR;
<i>899</i>&nbsp;    private double[] lfactorials;
<i>900</i>&nbsp;
<i>901</i>&nbsp;    private void setUpTables(final int MAX_N) {
<b class="nc"><i>902</i>&nbsp;        final double[] lints = new double[MAX_N];</b>
<b class="nc"><i>903</i>&nbsp;        lc2 = new double[MAX_N];</b>
<b class="nc"><i>904</i>&nbsp;        lfactorials = new double[MAX_N];</b>
<b class="nc"><i>905</i>&nbsp;        lNR = new double[MAX_N];</b>
<i>906</i>&nbsp;
<b class="nc"><i>907</i>&nbsp;        lints[0] = Double.NEGATIVE_INFINITY; //-infinity, should never be used</b>
<b class="nc"><i>908</i>&nbsp;        lints[1] = 0.0;</b>
<b class="nc"><i>909</i>&nbsp;        for (int i = 2; i &lt; MAX_N; ++i) {</b>
<b class="nc"><i>910</i>&nbsp;            lints[i] = Math.log(i);</b>
<i>911</i>&nbsp;        }
<i>912</i>&nbsp;
<b class="nc"><i>913</i>&nbsp;        lc2[0] = lc2[1] = Double.NEGATIVE_INFINITY;</b>
<b class="nc"><i>914</i>&nbsp;        for (int i = 2; i &lt; MAX_N; ++i) {</b>
<b class="nc"><i>915</i>&nbsp;            lc2[i] = lints[i] + lints[i - 1] - lg2;</b>
<i>916</i>&nbsp;        }
<i>917</i>&nbsp;
<b class="nc"><i>918</i>&nbsp;        lfactorials[0] = 0.0;</b>
<b class="nc"><i>919</i>&nbsp;        for (int i = 1; i &lt; MAX_N; ++i) {</b>
<b class="nc"><i>920</i>&nbsp;            lfactorials[i] = lfactorials[i - 1] + lints[i];</b>
<i>921</i>&nbsp;        }
<i>922</i>&nbsp;
<b class="nc"><i>923</i>&nbsp;        lNR[0] = Double.NEGATIVE_INFINITY; //-infinity, should never be used</b>
<b class="nc"><i>924</i>&nbsp;        lNR[1] = 0.0;</b>
<i>925</i>&nbsp;
<b class="nc"><i>926</i>&nbsp;        for (int i = 2; i &lt; MAX_N; ++i) {</b>
<b class="nc"><i>927</i>&nbsp;            lNR[i] = lNR[i - 1] + lc2[i];</b>
<i>928</i>&nbsp;        }
<i>929</i>&nbsp;    }
<i>930</i>&nbsp;
<i>931</i>&nbsp;    // @return true if the k&#39;th taxa is maximal under set inclusion, i.e. it is not contained in any other set
<i>932</i>&nbsp;    public static boolean isMaximal(final List&lt;TaxonSet&gt; taxa, final int k) {
<b class="nc"><i>933</i>&nbsp;        final TaxonSet tk = taxa.get(k);</b>
<b class="nc"><i>934</i>&nbsp;        for (int i = 0; i &lt; taxa.size(); ++i) {</b>
<b class="nc"><i>935</i>&nbsp;            if (i != k) {</b>
<b class="nc"><i>936</i>&nbsp;                if (taxa.get(i).containsAll(tk)) {</b>
<b class="nc"><i>937</i>&nbsp;                    return false;</b>
<i>938</i>&nbsp;                }
<i>939</i>&nbsp;            }
<i>940</i>&nbsp;        }
<b class="nc"><i>941</i>&nbsp;        return true;</b>
<i>942</i>&nbsp;    }
<i>943</i>&nbsp;
<i>944</i>&nbsp;
<i>945</i>&nbsp;    // Q2R Those generic functions could find a better home
<i>946</i>&nbsp;
<i>947</i>&nbsp;    public static int getTaxonIndex(final TreeInterface tree, final String taxon) {
<b class="nc"><i>948</i>&nbsp;        for (int i = 0; i &lt; tree.getNodeCount(); i++) {</b>
<b class="nc"><i>949</i>&nbsp;            final Node node = tree.getNode(i);</b>
<b class="nc"><i>950</i>&nbsp;            if (node.isLeaf() &amp;&amp; node.getID().equals(taxon)) {</b>
<b class="nc"><i>951</i>&nbsp;                return i;</b>
<i>952</i>&nbsp;            }
<i>953</i>&nbsp;        }
<b class="nc"><i>954</i>&nbsp;        return -1;</b>
<i>955</i>&nbsp;    }
<i>956</i>&nbsp;
<i>957</i>&nbsp;    public static Node getCommonAncestor(Node n1, Node n2) {
<i>958</i>&nbsp;        // assert n1.getTree() == n2.getTree();
<b class="nc"><i>959</i>&nbsp;        while (n1 != n2) {</b>
<b class="nc"><i>960</i>&nbsp;            if (n1.getHeight() &lt; n2.getHeight()) {</b>
<b class="nc"><i>961</i>&nbsp;                n1 = n1.getParent();</b>
<i>962</i>&nbsp;            } else {
<b class="nc"><i>963</i>&nbsp;                n2 = n2.getParent();</b>
<i>964</i>&nbsp;            }
<i>965</i>&nbsp;        }
<b class="nc"><i>966</i>&nbsp;        return n1;</b>
<i>967</i>&nbsp;    }
<i>968</i>&nbsp;
<i>969</i>&nbsp;    // A lightweight version for finding the most recent common ancestor of a group of taxa.
<i>970</i>&nbsp;    // return the node-ref of the MRCA.
<i>971</i>&nbsp;
<i>972</i>&nbsp;    // would be nice to use nodeRef&#39;s, but they are not preserved :(
<i>973</i>&nbsp;    public static Node getCommonAncestor(final TreeInterface tree, final int[] nodes) {
<b class="nc"><i>974</i>&nbsp;        Node cur = tree.getNode(nodes[0]);</b>
<i>975</i>&nbsp;
<b class="nc"><i>976</i>&nbsp;        for (int k = 1; k &lt; nodes.length; ++k) {</b>
<b class="nc"><i>977</i>&nbsp;            cur = getCommonAncestor(cur, tree.getNode(nodes[k]));</b>
<i>978</i>&nbsp;        }
<b class="nc"><i>979</i>&nbsp;        return cur;</b>
<i>980</i>&nbsp;    }
<i>981</i>&nbsp;
<i>982</i>&nbsp;    /**
<i>983</i>&nbsp;     * Count number of leaves in subtree whose root is node.
<i>984</i>&nbsp;     *
<i>985</i>&nbsp;     * @param node   subtree root
<i>986</i>&nbsp;     * @return the number of leaves under this node.
<i>987</i>&nbsp;     */
<i>988</i>&nbsp;    public static int getLeafCount(final Node node) {
<b class="nc"><i>989</i>&nbsp;        if (node.isLeaf()) {</b>
<b class="nc"><i>990</i>&nbsp;            return 1;</b>
<i>991</i>&nbsp;        }
<b class="nc"><i>992</i>&nbsp;        return getLeafCount(node.getLeft()) + getLeafCount(node.getRight());</b>
<i>993</i>&nbsp;    }
<i>994</i>&nbsp;
<i>995</i>&nbsp;    // log likelihood and clades heights
<i>996</i>&nbsp;
<i>997</i>&nbsp;    @Override
<i>998</i>&nbsp;    public void init(final PrintStream out) {
<b class="nc"><i>999</i>&nbsp;        out.print(getID() + &quot;\t&quot;);</b>
<b class="nc"><i>1000</i>&nbsp;        if (calcCalibrations) {</b>
<b class="nc"><i>1001</i>&nbsp;            for (final CalibrationPoint cp : orderedCalibrations) {</b>
<b class="nc"><i>1002</i>&nbsp;                out.print(cp.getID() + &quot;\t&quot;);</b>
<i>1003</i>&nbsp;            }
<i>1004</i>&nbsp;        }
<i>1005</i>&nbsp;    }
<i>1006</i>&nbsp;
<i>1007</i>&nbsp;    @Override
<i>1008</i>&nbsp;    public void log(final int sample, final PrintStream out) {
<b class="nc"><i>1009</i>&nbsp;        out.print(getCurrentLogP() + &quot;\t&quot;);</b>
<b class="nc"><i>1010</i>&nbsp;        if (calcCalibrations) {</b>
<b class="nc"><i>1011</i>&nbsp;            final TreeInterface tree = treeInput.get();</b>
<b class="nc"><i>1012</i>&nbsp;            for (int k = 0; k &lt; orderedCalibrations.length; ++k) {</b>
<b class="nc"><i>1013</i>&nbsp;                final CalibrationPoint cal = orderedCalibrations[k];</b>
<i>1014</i>&nbsp;                Node c;
<b class="nc"><i>1015</i>&nbsp;                final int[] taxk = xclades[k];</b>
<b class="nc"><i>1016</i>&nbsp;                if (taxk.length &gt; 1) {</b>
<i>1017</i>&nbsp;                    //  find MRCA of taxa
<b class="nc"><i>1018</i>&nbsp;                    c = getCommonAncestor(tree, taxk);</b>
<i>1019</i>&nbsp;                } else {
<b class="nc"><i>1020</i>&nbsp;                    c = tree.getNode(taxk[0]);</b>
<i>1021</i>&nbsp;                }
<i>1022</i>&nbsp;
<b class="nc"><i>1023</i>&nbsp;                if (cal.forParent()) {</b>
<b class="nc"><i>1024</i>&nbsp;                    c = c.getParent();</b>
<i>1025</i>&nbsp;                }
<i>1026</i>&nbsp;
<b class="nc"><i>1027</i>&nbsp;                final double h = c.getHeight();</b>
<b class="nc"><i>1028</i>&nbsp;                out.print(h + &quot;\t&quot;);</b>
<i>1029</i>&nbsp;            }
<i>1030</i>&nbsp;        }
<i>1031</i>&nbsp;    }
<i>1032</i>&nbsp;
<i>1033</i>&nbsp;    @Override
<i>1034</i>&nbsp;    protected boolean requiresRecalculation() {
<b class="nc"><i>1035</i>&nbsp;        if( super.requiresRecalculation() || birthRateInput.get().somethingIsDirty() ) {</b>
<b class="nc"><i>1036</i>&nbsp;            return true;</b>
<i>1037</i>&nbsp;        }
<b class="nc"><i>1038</i>&nbsp;        if( !isYule ) {</b>
<b class="nc"><i>1039</i>&nbsp;            RealParameter p = deathToBirthRatioInput.get();</b>
<b class="nc"><i>1040</i>&nbsp;            if( p != null &amp;&amp; p.somethingIsDirty() ) {</b>
<b class="nc"><i>1041</i>&nbsp;                return true;</b>
<i>1042</i>&nbsp;            }
<b class="nc"><i>1043</i>&nbsp;            p = sampleProbabilityInput.get();</b>
<b class="nc"><i>1044</i>&nbsp;            if( p != null &amp;&amp; p.somethingIsDirty() ) {</b>
<b class="nc"><i>1045</i>&nbsp;                return true;</b>
<i>1046</i>&nbsp;            }
<i>1047</i>&nbsp;        }
<b class="nc"><i>1048</i>&nbsp;        return false;</b>
<i>1049</i>&nbsp;    }
<i>1050</i>&nbsp;    
<i>1051</i>&nbsp;    @Override
<i>1052</i>&nbsp;    public boolean canHandleTipDates() {
<b class="nc"><i>1053</i>&nbsp;		return false;</b>
<i>1054</i>&nbsp;	}
<i>1055</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2016-05-30 16:46</div>
</div>
</body>
</html>
