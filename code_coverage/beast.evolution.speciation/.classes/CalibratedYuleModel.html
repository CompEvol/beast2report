


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: CalibratedYuleModel</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">beast.evolution.speciation</a> ]
</div>

<h1>Coverage Summary for Class: CalibratedYuleModel (beast.evolution.speciation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CalibratedYuleModel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 435)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CalibratedYuleModel$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CalibratedYuleModel$Type</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/ 443)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;package beast.evolution.speciation;
<i>2</i>&nbsp;
<i>3</i>&nbsp;
<i>4</i>&nbsp;import java.io.PrintStream;
<i>5</i>&nbsp;import java.util.ArrayList;
<i>6</i>&nbsp;import java.util.Arrays;
<i>7</i>&nbsp;import java.util.List;
<i>8</i>&nbsp;
<i>9</i>&nbsp;import org.apache.commons.math.MathException;
<i>10</i>&nbsp;
<i>11</i>&nbsp;import beast.core.Citation;
<i>12</i>&nbsp;import beast.core.Description;
<i>13</i>&nbsp;import beast.core.Distribution;
<i>14</i>&nbsp;import beast.core.Input;
<i>15</i>&nbsp;import beast.core.Input.Validate;
<i>16</i>&nbsp;import beast.core.parameter.RealParameter;
<i>17</i>&nbsp;import beast.core.util.CompoundDistribution;
<i>18</i>&nbsp;import beast.core.util.Log;
<i>19</i>&nbsp;import beast.evolution.alignment.TaxonSet;
<i>20</i>&nbsp;import beast.evolution.tree.Node;
<i>21</i>&nbsp;import beast.evolution.tree.Tree;
<i>22</i>&nbsp;import beast.evolution.tree.TreeInterface;
<i>23</i>&nbsp;import beast.math.distributions.MRCAPrior;
<i>24</i>&nbsp;import beast.math.distributions.ParametricDistribution;
<i>25</i>&nbsp;import beast.math.statistic.RPNcalculator;
<i>26</i>&nbsp;
<i>27</i>&nbsp;/**
<i>28</i>&nbsp; * @author Joseph Heled
<i>29</i>&nbsp; */
<i>30</i>&nbsp;
<i>31</i>&nbsp;
<b class="nc"><i>32</i>&nbsp;@Description(&quot;Yule prior with calibrated monophyletic clades. With this prior, the marginal distribution of the&quot; +</b>
<i>33</i>&nbsp;        &quot; calibrated nodes (the MRCA of clades) is identical to the specified calibration, but the Yule is not preserved over&quot; +
<i>34</i>&nbsp;        &quot; the whole tree space, only among sub-spaces.&quot;)
<i>35</i>&nbsp;@Citation(value =
<i>36</i>&nbsp;        &quot;Heled J, Drummond AJ (2012) Calibrated Tree Priors for Relaxed Phylogenetics\n&quot; +
<i>37</i>&nbsp;                &quot;  and Divergence Time Estimation. Systematic Biology 61(1):138-149.&quot;
<i>38</i>&nbsp;        , DOI = &quot;10.1093/sysbio/syr087&quot;, year = 2012, firstAuthorSurname = &quot;heled&quot;)
<i>39</i>&nbsp;public class CalibratedYuleModel extends SpeciesTreeDistribution {
<i>40</i>&nbsp;
<b class="nc"><i>41</i>&nbsp;    public static enum Type {</b>
<b class="nc"><i>42</i>&nbsp;        NONE(&quot;none&quot;),</b>
<b class="nc"><i>43</i>&nbsp;        OVER_ALL_TOPOS(&quot;full&quot;),</b>
<b class="nc"><i>44</i>&nbsp;        OVER_RANKED_COUNTS(&quot;restricted&quot;);</b>
<i>45</i>&nbsp;
<b class="nc"><i>46</i>&nbsp;        Type(final String name) {</b>
<b class="nc"><i>47</i>&nbsp;            this.ename = name;</b>
<i>48</i>&nbsp;        }
<i>49</i>&nbsp;
<i>50</i>&nbsp;        @Override
<i>51</i>&nbsp;		public String toString() {
<b class="nc"><i>52</i>&nbsp;            return ename;</b>
<i>53</i>&nbsp;        }
<i>54</i>&nbsp;
<i>55</i>&nbsp;        private final String ename;
<i>56</i>&nbsp;    }
<i>57</i>&nbsp;
<i>58</i>&nbsp;    // Q2R does this makes sense, or it has to be a realParameter??
<b class="nc"><i>59</i>&nbsp;    final public Input&lt;RealParameter&gt; birthRateInput =</b>
<i>60</i>&nbsp;            new Input&lt;&gt;(&quot;birthRate&quot;, &quot;birth rate of splitting a linage into two&quot;, Validate.REQUIRED);
<i>61</i>&nbsp;
<b class="nc"><i>62</i>&nbsp;    final public Input&lt;List&lt;CalibrationPoint&gt;&gt; calibrationsInput =</b>
<i>63</i>&nbsp;            new Input&lt;&gt;(&quot;calibrations&quot;, &quot;Set of calibrated nodes&quot;, new ArrayList&lt;&gt;());
<i>64</i>&nbsp;
<b class="nc"><i>65</i>&nbsp;    final public Input&lt;Type&gt; correctionTypeInput = new Input&lt;&gt;(&quot;type&quot;, &quot;Type of correction: none for no correction &quot; +</b>
<i>66</i>&nbsp;            &quot;(same as BEAST1), full for Yule-like over calibrated times, and restricted for Yule-like over calibrated&quot; +
<i>67</i>&nbsp;            &quot; times and ranked topology (default &#39;full&#39;). However, &#39;full&#39;&quot; +
<i>68</i>&nbsp;            &quot; is generally slow except for in a few special cases, such as a single clade or two nested clades.&quot;,
<b class="nc"><i>69</i>&nbsp;            Type.OVER_ALL_TOPOS, Type.values());</b>
<i>70</i>&nbsp;
<b class="nc"><i>71</i>&nbsp;    final public Input&lt;RPNcalculator&gt; userMarInput = new Input&lt;&gt;(&quot;logMarginal&quot;,</b>
<i>72</i>&nbsp;            &quot;Used provided correction (log of marginal) for special cases.&quot;, (RPNcalculator) null);
<i>73</i>&nbsp;
<i>74</i>&nbsp;    // Which correction to apply
<i>75</i>&nbsp;    private Type type;
<i>76</i>&nbsp;
<i>77</i>&nbsp;    // Calibration points, (partially) sorted by set inclusion operator on clades. (remember that partially overlapping clades are not allowed)
<i>78</i>&nbsp;    CalibrationPoint[] orderedCalibrations;
<i>79</i>&nbsp;
<i>80</i>&nbsp;    // taxa of calibrated points, in same order as &#39;orderedCalibrations&#39; above. The clade is represented as an array of integers, where each
<i>81</i>&nbsp;    // integer is the &quot;node index&quot; of the taxon in the tree, that is tree.getNode(xclades[i][k]) is the node for the k&#39;th taxon of the i&#39;th point.
<i>82</i>&nbsp;    private int[][] xclades;
<i>83</i>&nbsp;
<i>84</i>&nbsp;    // taxaPartialOrder[i] contains all clades immediately preceding the i&#39;th clade under clade partial ordering.
<i>85</i>&nbsp;    // (i&#39;th clade is orderedCalibrations[i]/xclades[i]). clades are given as their index into orderedCalibrations (and so into xclades as well).
<i>86</i>&nbsp;    private int[][] taxaPartialOrder;
<i>87</i>&nbsp;
<b class="nc"><i>88</i>&nbsp;    RPNcalculator userPDF = null; //Q2R  but would that work propagation-wise</b>
<i>89</i>&nbsp;
<i>90</i>&nbsp;    // whether to calculated the contribution of each of the calibrations
<i>91</i>&nbsp;    // should be false, when the calibrations come from MRCA priors of a parent CompoundDistribution 
<b class="nc"><i>92</i>&nbsp;    boolean calcCalibrations = true;</b>
<i>93</i>&nbsp;
<b class="nc"><i>94</i>&nbsp;    public CalibratedYuleModel() {</b>
<i>95</i>&nbsp;    }
<i>96</i>&nbsp;
<i>97</i>&nbsp;    @Override
<i>98</i>&nbsp;    public void initAndValidate() {
<b class="nc"><i>99</i>&nbsp;        super.initAndValidate();</b>
<i>100</i>&nbsp;
<b class="nc"><i>101</i>&nbsp;        type = correctionTypeInput.get();</b>
<i>102</i>&nbsp;
<b class="nc"><i>103</i>&nbsp;        final TreeInterface tree = treeInput.get();</b>
<i>104</i>&nbsp;
<i>105</i>&nbsp;        // shallow copy. we shall change cals later
<b class="nc"><i>106</i>&nbsp;        final List&lt;CalibrationPoint&gt; cals = new ArrayList&lt;&gt;(calibrationsInput.get());</b>
<b class="nc"><i>107</i>&nbsp;        int calCount = cals.size();</b>
<b class="nc"><i>108</i>&nbsp;        final List&lt;TaxonSet&gt; taxaSets = new ArrayList&lt;&gt;(calCount);</b>
<b class="nc"><i>109</i>&nbsp;        if (cals.size() &gt; 0) {</b>
<b class="nc"><i>110</i>&nbsp;            xclades = new int[calCount][];</b>
<i>111</i>&nbsp;
<i>112</i>&nbsp;            // convenience
<b class="nc"><i>113</i>&nbsp;            for (final CalibrationPoint cal : cals) {</b>
<b class="nc"><i>114</i>&nbsp;                taxaSets.add(cal.taxa());</b>
<b class="nc"><i>115</i>&nbsp;            }</b>
<i>116</i>&nbsp;
<i>117</i>&nbsp;        } else {
<i>118</i>&nbsp;            // find calibration points from prior
<b class="nc"><i>119</i>&nbsp;            for (final Object beastObject : getOutputs()) {</b>
<b class="nc"><i>120</i>&nbsp;                if (beastObject instanceof CompoundDistribution) {</b>
<b class="nc"><i>121</i>&nbsp;                    final CompoundDistribution prior = (CompoundDistribution) beastObject;</b>
<b class="nc"><i>122</i>&nbsp;                    for (final Distribution distr : prior.pDistributions.get()) {</b>
<b class="nc"><i>123</i>&nbsp;                        if (distr instanceof MRCAPrior) {</b>
<b class="nc"><i>124</i>&nbsp;                            final MRCAPrior _MRCAPrior = (MRCAPrior) distr;</b>
<i>125</i>&nbsp;                            // make sure MRCAPrior is monophyletic
<b class="nc"><i>126</i>&nbsp;                            if (_MRCAPrior.distInput.get() != null) {</b>
<i>127</i>&nbsp;                                // make sure MRCAPrior is monophyletic
<b class="nc"><i>128</i>&nbsp;                                if (!_MRCAPrior.isMonophyleticInput.get()) {</b>
<b class="nc"><i>129</i>&nbsp;                                    throw new IllegalArgumentException(&quot;MRCAPriors must be monophyletic for Calibrated Yule prior&quot;);</b>
<i>130</i>&nbsp;                                }
<i>131</i>&nbsp;                                // create CalibrationPoint from MRCAPrior
<b class="nc"><i>132</i>&nbsp;                                final CalibrationPoint cal = new CalibrationPoint();</b>
<b class="nc"><i>133</i>&nbsp;                                cal.distInput.setValue(_MRCAPrior.distInput.get(), cal);</b>
<b class="nc"><i>134</i>&nbsp;                                cal.taxonsetInput.setValue(_MRCAPrior.taxonsetInput.get(), cal);</b>
<b class="nc"><i>135</i>&nbsp;                                cal.initAndValidate();</b>
<b class="nc"><i>136</i>&nbsp;                                cals.add(cal);</b>
<b class="nc"><i>137</i>&nbsp;                                taxaSets.add(cal.taxa());</b>
<b class="nc"><i>138</i>&nbsp;                                cal.taxa().initAndValidate();</b>
<b class="nc"><i>139</i>&nbsp;                                calCount++;</b>
<b class="nc"><i>140</i>&nbsp;                                calcCalibrations = false;</b>
<b class="nc"><i>141</i>&nbsp;                            } else {</b>
<b class="nc"><i>142</i>&nbsp;                                if (_MRCAPrior.isMonophyleticInput.get()) {</b>
<b class="nc"><i>143</i>&nbsp;                                    Log.warning.println(&quot;WARNING: MRCAPriors (&quot; + _MRCAPrior.getID() + &quot;) must have a distribution when monophyletic. Ignored for Calibrated Yule prior&quot;);</b>
<i>144</i>&nbsp;                                } else {
<b class="nc"><i>145</i>&nbsp;                                	Log.warning.println(&quot;WARNING: MRCAPriors (&quot; + _MRCAPrior.getID() + &quot;) found that is not monophyletic. Ignored for Calibrated Yule prior&quot;);                                	</b>
<i>146</i>&nbsp;                                }
<i>147</i>&nbsp;                            }
<i>148</i>&nbsp;                        }
<b class="nc"><i>149</i>&nbsp;                    }</b>
<i>150</i>&nbsp;                }
<b class="nc"><i>151</i>&nbsp;            }</b>
<b class="nc"><i>152</i>&nbsp;            xclades = new int[calCount][];</b>
<i>153</i>&nbsp;        }
<b class="nc"><i>154</i>&nbsp;        if (calCount == 0) {</b>
<b class="nc"><i>155</i>&nbsp;        	Log.warning.println(&quot;WARNING: Calibrated Yule prior could not find any properly configured calibrations. Expect this to crash in a BEAST run.&quot;);                                	</b>
<i>156</i>&nbsp;            // assume we are in beauti, back off for now
<i>157</i>&nbsp;            return;
<i>158</i>&nbsp;        }
<i>159</i>&nbsp;
<b class="nc"><i>160</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>161</i>&nbsp;            final TaxonSet tk = taxaSets.get(k);</b>
<b class="nc"><i>162</i>&nbsp;            for (int i = k + 1; i &lt; calCount; ++i) {</b>
<b class="nc"><i>163</i>&nbsp;                final TaxonSet ti = taxaSets.get(i);</b>
<b class="nc"><i>164</i>&nbsp;                if (ti.containsAny(tk)) {</b>
<b class="nc"><i>165</i>&nbsp;                    if (!(ti.containsAll(tk) || tk.containsAll(ti))) {</b>
<b class="nc"><i>166</i>&nbsp;                        throw new IllegalArgumentException(&quot;Overlapping taxaSets??&quot;);</b>
<i>167</i>&nbsp;                    }
<i>168</i>&nbsp;                }
<i>169</i>&nbsp;            }
<i>170</i>&nbsp;        }
<i>171</i>&nbsp;
<b class="nc"><i>172</i>&nbsp;        orderedCalibrations = new CalibrationPoint[calCount];</b>
<i>173</i>&nbsp;
<i>174</i>&nbsp;        {
<b class="nc"><i>175</i>&nbsp;            int loc = taxaSets.size() - 1;</b>
<b class="nc"><i>176</i>&nbsp;            while (loc &gt;= 0) {</b>
<b class="nc"><i>177</i>&nbsp;                assert loc == taxaSets.size() - 1;</b>
<i>178</i>&nbsp;                //  place maximal taxaSets at end one at a time
<b class="nc"><i>179</i>&nbsp;                int k = 0;</b>
<b class="nc"><i>180</i>&nbsp;                for (/**/; k &lt; taxaSets.size(); ++k) {</b>
<b class="nc"><i>181</i>&nbsp;                    if (isMaximal(taxaSets, k)) {</b>
<b class="nc"><i>182</i>&nbsp;                        break;</b>
<i>183</i>&nbsp;                    }
<i>184</i>&nbsp;                }
<i>185</i>&nbsp;
<b class="nc"><i>186</i>&nbsp;                final List&lt;String&gt; tk = taxaSets.get(k).asStringList();</b>
<b class="nc"><i>187</i>&nbsp;                final int tkcount = tk.size();</b>
<b class="nc"><i>188</i>&nbsp;                this.xclades[loc] = new int[tkcount];</b>
<b class="nc"><i>189</i>&nbsp;                for (int nt = 0; nt &lt; tkcount; ++nt) {</b>
<b class="nc"><i>190</i>&nbsp;                    final int taxonIndex = getTaxonIndex(tree, tk.get(nt));</b>
<b class="nc"><i>191</i>&nbsp;                    this.xclades[loc][nt] = taxonIndex;</b>
<b class="nc"><i>192</i>&nbsp;                    if (taxonIndex &lt; 0) {</b>
<b class="nc"><i>193</i>&nbsp;                        throw new IllegalArgumentException(&quot;Taxon not found in tree: &quot; + tk.get(nt));</b>
<i>194</i>&nbsp;                    }
<i>195</i>&nbsp;                }
<i>196</i>&nbsp;
<b class="nc"><i>197</i>&nbsp;                orderedCalibrations[loc] = cals.remove(k);</b>
<b class="nc"><i>198</i>&nbsp;                taxaSets.remove(k);</b>
<i>199</i>&nbsp;                // cals and taxaSets should match
<b class="nc"><i>200</i>&nbsp;                --loc;</b>
<b class="nc"><i>201</i>&nbsp;            }</b>
<i>202</i>&nbsp;        }
<i>203</i>&nbsp;
<i>204</i>&nbsp;        // tio[i] will contain all taxaSets contained in the i&#39;th clade, in the form of thier index into orderedCalibrations
<i>205</i>&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
<b class="nc"><i>206</i>&nbsp;		final List&lt;Integer&gt;[] tio = new List[orderedCalibrations.length];</b>
<b class="nc"><i>207</i>&nbsp;        for (int k = 0; k &lt; orderedCalibrations.length; ++k) {</b>
<b class="nc"><i>208</i>&nbsp;            tio[k] = new ArrayList&lt;&gt;();</b>
<i>209</i>&nbsp;        }
<i>210</i>&nbsp;
<b class="nc"><i>211</i>&nbsp;        for (int k = 0; k &lt; orderedCalibrations.length; ++k) {</b>
<b class="nc"><i>212</i>&nbsp;            final TaxonSet txk = orderedCalibrations[k].taxa();</b>
<b class="nc"><i>213</i>&nbsp;            for (int i = k + 1; i &lt; orderedCalibrations.length; ++i) {</b>
<b class="nc"><i>214</i>&nbsp;                if (orderedCalibrations[i].taxa().containsAll(txk)) {</b>
<b class="nc"><i>215</i>&nbsp;                    tio[i].add(k);</b>
<b class="nc"><i>216</i>&nbsp;                    break;</b>
<i>217</i>&nbsp;                }
<i>218</i>&nbsp;            }
<i>219</i>&nbsp;        }
<i>220</i>&nbsp;
<b class="nc"><i>221</i>&nbsp;        this.taxaPartialOrder = new int[orderedCalibrations.length][];</b>
<b class="nc"><i>222</i>&nbsp;        for (int k = 0; k &lt; orderedCalibrations.length; ++k) {</b>
<b class="nc"><i>223</i>&nbsp;            final List&lt;Integer&gt; tiok = tio[k];</b>
<i>224</i>&nbsp;
<b class="nc"><i>225</i>&nbsp;            this.taxaPartialOrder[k] = new int[tiok.size()];</b>
<b class="nc"><i>226</i>&nbsp;            for (int j = 0; j &lt; tiok.size(); ++j) {</b>
<b class="nc"><i>227</i>&nbsp;                this.taxaPartialOrder[k][j] = tiok.get(j);</b>
<i>228</i>&nbsp;            }
<i>229</i>&nbsp;        }
<i>230</i>&nbsp;
<i>231</i>&nbsp;        // true if clade is not contained in any other clade
<b class="nc"><i>232</i>&nbsp;        final boolean[] maximal = new boolean[calCount];</b>
<b class="nc"><i>233</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>234</i>&nbsp;            maximal[k] = true;</b>
<i>235</i>&nbsp;        }
<i>236</i>&nbsp;
<b class="nc"><i>237</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>238</i>&nbsp;            for (final int i : this.taxaPartialOrder[k]) {</b>
<b class="nc"><i>239</i>&nbsp;                maximal[i] = false;</b>
<i>240</i>&nbsp;            }
<i>241</i>&nbsp;        }
<i>242</i>&nbsp;
<b class="nc"><i>243</i>&nbsp;        userPDF = userMarInput.get();</b>
<b class="nc"><i>244</i>&nbsp;        if (userPDF == null) {</b>
<i>245</i>&nbsp;
<b class="nc"><i>246</i>&nbsp;            if (type == Type.OVER_ALL_TOPOS) {</b>
<b class="nc"><i>247</i>&nbsp;                if (calCount == 1) {</b>
<i>248</i>&nbsp;                    // closed form formula
<i>249</i>&nbsp;                } else {
<b class="nc"><i>250</i>&nbsp;                    boolean anyParent = false;</b>
<b class="nc"><i>251</i>&nbsp;                    for (final CalibrationPoint c : orderedCalibrations) {</b>
<b class="nc"><i>252</i>&nbsp;                        if (c.forParentInput.get()) {</b>
<b class="nc"><i>253</i>&nbsp;                            anyParent = true;</b>
<i>254</i>&nbsp;                        }
<i>255</i>&nbsp;                    }
<b class="nc"><i>256</i>&nbsp;                    if (anyParent) {</b>
<b class="nc"><i>257</i>&nbsp;                        throw new IllegalArgumentException(&quot;Sorry, not implemented: calibration on parent for more than one clade.&quot;);</b>
<i>258</i>&nbsp;                    }
<b class="nc"><i>259</i>&nbsp;                    if (calCount == 2 &amp;&amp; orderedCalibrations[1].taxa().containsAll(orderedCalibrations[0].taxa())) {</b>
<i>260</i>&nbsp;                        // closed form formulas
<i>261</i>&nbsp;                    } else {
<b class="nc"><i>262</i>&nbsp;                        setUpTables(tree.getLeafNodeCount() + 1);</b>
<b class="nc"><i>263</i>&nbsp;                        linsIter = new CalibrationLineagesIterator(this.xclades, this.taxaPartialOrder, maximal,</b>
<b class="nc"><i>264</i>&nbsp;                                tree.getLeafNodeCount());</b>
<b class="nc"><i>265</i>&nbsp;                        lastHeights = new double[calCount];</b>
<i>266</i>&nbsp;                    }
<b class="nc"><i>267</i>&nbsp;                }</b>
<b class="nc"><i>268</i>&nbsp;            } else if (type == Type.OVER_RANKED_COUNTS) {</b>
<b class="nc"><i>269</i>&nbsp;                setUpTables(tree.getLeafNodeCount() + 1);</b>
<i>270</i>&nbsp;            }
<i>271</i>&nbsp;        }
<i>272</i>&nbsp;
<b class="nc"><i>273</i>&nbsp;        final List&lt;Node&gt; leafs = tree.getExternalNodes();</b>
<b class="nc"><i>274</i>&nbsp;        final double height = leafs.get(0).getHeight();</b>
<b class="nc"><i>275</i>&nbsp;        for (final Node leaf : leafs) {</b>
<b class="nc"><i>276</i>&nbsp;            if (Math.abs(leaf.getHeight() - height) &gt; 1e-8) {</b>
<b class="nc"><i>277</i>&nbsp;            	Log.warning.println(&quot;WARNING: Calibrated Yule Model cannot handle dated tips. Use for example a coalescent prior instead.&quot;);</b>
<b class="nc"><i>278</i>&nbsp;                break;</b>
<i>279</i>&nbsp;            }
<b class="nc"><i>280</i>&nbsp;        }</b>
<i>281</i>&nbsp;    }
<i>282</i>&nbsp;
<i>283</i>&nbsp;    public Tree compatibleInitialTree() throws MathException {
<b class="nc"><i>284</i>&nbsp;        final int calCount = orderedCalibrations.length;</b>
<b class="nc"><i>285</i>&nbsp;        final double[] lowBound = new double[calCount];</b>
<b class="nc"><i>286</i>&nbsp;        final double[] cladeHeight = new double[calCount];</b>
<i>287</i>&nbsp;
<i>288</i>&nbsp;        // get lower  bound: max(lower bound of dist , bounds of nested clades)
<b class="nc"><i>289</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>290</i>&nbsp;            final CalibrationPoint cal = orderedCalibrations[k];</b>
<b class="nc"><i>291</i>&nbsp;            final ParametricDistribution dist = cal.dist();</b>
<i>292</i>&nbsp;            //final double offset = dist.getOffset();
<b class="nc"><i>293</i>&nbsp;            lowBound[k] = dist.inverseCumulativeProbability(0);</b>
<i>294</i>&nbsp;            // those are node heights
<b class="nc"><i>295</i>&nbsp;            if (lowBound[k] &lt; 0) {</b>
<b class="nc"><i>296</i>&nbsp;                lowBound[k] = 0;</b>
<i>297</i>&nbsp;            }
<b class="nc"><i>298</i>&nbsp;            for (final int i : taxaPartialOrder[k]) {</b>
<b class="nc"><i>299</i>&nbsp;                lowBound[k] = Math.max(lowBound[k], lowBound[i]);</b>
<i>300</i>&nbsp;            }
<b class="nc"><i>301</i>&nbsp;            cladeHeight[k] = dist.inverseCumulativeProbability(1);</b>
<i>302</i>&nbsp;//            if (! Double.isInfinite(cladeHeight[k])) {
<i>303</i>&nbsp;//              cladeHeight[k] += offset;
<i>304</i>&nbsp;//            }
<i>305</i>&nbsp;        }
<i>306</i>&nbsp;
<b class="nc"><i>307</i>&nbsp;        for (int k = calCount - 1; k &gt;= 0; --k) {</b>
<i>308</i>&nbsp;            //  cladeHeight[k] should be the upper bound of k
<b class="nc"><i>309</i>&nbsp;            double upper = cladeHeight[k];</b>
<b class="nc"><i>310</i>&nbsp;            if (Double.isInfinite(upper)) {</b>
<b class="nc"><i>311</i>&nbsp;                upper = lowBound[k] + 1;</b>
<i>312</i>&nbsp;            }
<b class="nc"><i>313</i>&nbsp;            cladeHeight[k] = (upper + lowBound[k]) / 2.0;</b>
<i>314</i>&nbsp;
<b class="nc"><i>315</i>&nbsp;            for (final int i : taxaPartialOrder[k]) {</b>
<b class="nc"><i>316</i>&nbsp;                cladeHeight[i] = Math.min(cladeHeight[i], cladeHeight[k]);</b>
<i>317</i>&nbsp;            }
<i>318</i>&nbsp;        }
<i>319</i>&nbsp;
<b class="nc"><i>320</i>&nbsp;        final TreeInterface tree = treeInput.get();</b>
<b class="nc"><i>321</i>&nbsp;        final int nodeCount = tree.getLeafNodeCount();</b>
<b class="nc"><i>322</i>&nbsp;        final boolean[] used = new boolean[nodeCount];</b>
<i>323</i>&nbsp;
<b class="nc"><i>324</i>&nbsp;        int curLeaf = -1;</b>
<b class="nc"><i>325</i>&nbsp;        int curInternal = nodeCount - 1;</b>
<i>326</i>&nbsp;
<b class="nc"><i>327</i>&nbsp;        final Node[] subTree = new Node[calCount];</b>
<b class="nc"><i>328</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>329</i>&nbsp;            final List&lt;Integer&gt; freeTaxa = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>330</i>&nbsp;            for (final int ti : xclades[k]) {</b>
<b class="nc"><i>331</i>&nbsp;                freeTaxa.add(ti);</b>
<i>332</i>&nbsp;            }
<b class="nc"><i>333</i>&nbsp;            for (final int i : taxaPartialOrder[k]) {</b>
<b class="nc"><i>334</i>&nbsp;                for (final int u : xclades[i]) {</b>
<b class="nc"><i>335</i>&nbsp;                    freeTaxa.remove(new Integer(u));</b>
<i>336</i>&nbsp;                }
<i>337</i>&nbsp;            }
<i>338</i>&nbsp;
<b class="nc"><i>339</i>&nbsp;            final List&lt;Node&gt; sbs = new ArrayList&lt;&gt;();</b>
<b class="nc"><i>340</i>&nbsp;            for (final int i : freeTaxa) {</b>
<b class="nc"><i>341</i>&nbsp;                final Node n = new Node(tree.getNode(i).getID());</b>
<b class="nc"><i>342</i>&nbsp;                n.setNr(++curLeaf);</b>
<b class="nc"><i>343</i>&nbsp;                n.setHeight(0.0);</b>
<b class="nc"><i>344</i>&nbsp;                sbs.add(n);</b>
<i>345</i>&nbsp;
<b class="nc"><i>346</i>&nbsp;                used[i] = true;</b>
<b class="nc"><i>347</i>&nbsp;            }</b>
<b class="nc"><i>348</i>&nbsp;            for (final int i : taxaPartialOrder[k]) {</b>
<b class="nc"><i>349</i>&nbsp;                sbs.add(subTree[i]);</b>
<b class="nc"><i>350</i>&nbsp;                subTree[i] = null;</b>
<i>351</i>&nbsp;            }
<b class="nc"><i>352</i>&nbsp;            final double base = sbs.get(sbs.size() - 1).getHeight();</b>
<b class="nc"><i>353</i>&nbsp;            final double step = (cladeHeight[k] - base) / (sbs.size() - 1);</b>
<i>354</i>&nbsp;
<b class="nc"><i>355</i>&nbsp;            Node tr = sbs.get(0);</b>
<b class="nc"><i>356</i>&nbsp;            for (int i = 1; i &lt; sbs.size(); ++i) {</b>
<b class="nc"><i>357</i>&nbsp;                tr = Node.connect(tr, sbs.get(i), base + i * step);</b>
<b class="nc"><i>358</i>&nbsp;                tr.setNr(++curInternal);</b>
<i>359</i>&nbsp;            }
<b class="nc"><i>360</i>&nbsp;            subTree[k] = tr;</b>
<i>361</i>&nbsp;        }
<i>362</i>&nbsp;
<b class="nc"><i>363</i>&nbsp;        Node finalTree = subTree[calCount - 1];</b>
<b class="nc"><i>364</i>&nbsp;        double h = cladeHeight[calCount - 1];</b>
<i>365</i>&nbsp;
<b class="nc"><i>366</i>&nbsp;        for (int k = 0; k &lt; calCount - 1; ++k) {</b>
<b class="nc"><i>367</i>&nbsp;            final Node s = subTree[k];</b>
<b class="nc"><i>368</i>&nbsp;            if( s != null ) {</b>
<b class="nc"><i>369</i>&nbsp;                h = Math.max(h, cladeHeight[k]) + 1;</b>
<b class="nc"><i>370</i>&nbsp;                finalTree = Node.connect(finalTree, s, h);</b>
<b class="nc"><i>371</i>&nbsp;                finalTree.setNr(++curInternal);</b>
<i>372</i>&nbsp;            }
<i>373</i>&nbsp;        }
<i>374</i>&nbsp;
<b class="nc"><i>375</i>&nbsp;        for (int k = 0; k &lt; used.length; ++k) {</b>
<b class="nc"><i>376</i>&nbsp;            if (!used[k]) {</b>
<b class="nc"><i>377</i>&nbsp;                final String tx = tree.getNode(k).getID();</b>
<b class="nc"><i>378</i>&nbsp;                final Node n = new Node(tx);</b>
<b class="nc"><i>379</i>&nbsp;                n.setHeight(0.0);</b>
<b class="nc"><i>380</i>&nbsp;                n.setNr(++curLeaf);</b>
<b class="nc"><i>381</i>&nbsp;                finalTree = Node.connect(finalTree, n, h + 1);</b>
<b class="nc"><i>382</i>&nbsp;                finalTree.setNr(++curInternal);</b>
<b class="nc"><i>383</i>&nbsp;                h += 1;</b>
<i>384</i>&nbsp;            }
<i>385</i>&nbsp;        }
<b class="nc"><i>386</i>&nbsp;        final Tree t = new Tree();</b>
<b class="nc"><i>387</i>&nbsp;        t.setRoot(finalTree);</b>
<b class="nc"><i>388</i>&nbsp;        t.initAndValidate();</b>
<b class="nc"><i>389</i>&nbsp;        return t;</b>
<i>390</i>&nbsp;    }
<i>391</i>&nbsp;
<i>392</i>&nbsp;    @Override
<i>393</i>&nbsp;    public double calculateTreeLogLikelihood(final TreeInterface tree) {
<b class="nc"><i>394</i>&nbsp;        final double lam = birthRateInput.get().getArrayValue();</b>
<i>395</i>&nbsp;
<b class="nc"><i>396</i>&nbsp;        double logL = calculateYuleLikelihood(tree, lam);</b>
<i>397</i>&nbsp;
<b class="nc"><i>398</i>&nbsp;        final double mar = getCorrection(tree, lam);</b>
<b class="nc"><i>399</i>&nbsp;        logL += mar;</b>
<b class="nc"><i>400</i>&nbsp;        return logL;</b>
<i>401</i>&nbsp;    }
<i>402</i>&nbsp;
<i>403</i>&nbsp;    private static double calculateYuleLikelihood(final TreeInterface tree, final double lam) {
<b class="nc"><i>404</i>&nbsp;        final int taxonCount = tree.getLeafNodeCount();</b>
<i>405</i>&nbsp;
<i>406</i>&nbsp;        // add all lambda multipliers here
<i>407</i>&nbsp;        // No normalization at the moment.  for n! use logGamma(taxonCount + 1);
<b class="nc"><i>408</i>&nbsp;        double logL = (taxonCount - 1) * Math.log(lam);</b>
<i>409</i>&nbsp;
<b class="nc"><i>410</i>&nbsp;        final Node[] nodes = tree.getNodesAsArray();</b>
<b class="nc"><i>411</i>&nbsp;        for (int i = taxonCount; i &lt; nodes.length; i++) {</b>
<b class="nc"><i>412</i>&nbsp;            final Node node = nodes[i];</b>
<b class="nc"><i>413</i>&nbsp;            assert (!node.isLeaf());</b>
<b class="nc"><i>414</i>&nbsp;            final double height = node.getHeight();</b>
<b class="nc"><i>415</i>&nbsp;            final double mrh = -lam * height;</b>
<b class="nc"><i>416</i>&nbsp;            logL += mrh + (node.isRoot() ? mrh : 0);</b>
<i>417</i>&nbsp;        }
<b class="nc"><i>418</i>&nbsp;        return logL;</b>
<i>419</i>&nbsp;    }
<i>420</i>&nbsp;
<i>421</i>&nbsp;    public double getCorrection(final TreeInterface tree, final double lam) {
<b class="nc"><i>422</i>&nbsp;        double logL = 0.0;</b>
<i>423</i>&nbsp;
<b class="nc"><i>424</i>&nbsp;        final int calCount = orderedCalibrations.length;</b>
<b class="nc"><i>425</i>&nbsp;        final double[] hs = new double[calCount];</b>
<i>426</i>&nbsp;
<b class="nc"><i>427</i>&nbsp;        for (int k = 0; k &lt; calCount; ++k) {</b>
<b class="nc"><i>428</i>&nbsp;            final CalibrationPoint cal = orderedCalibrations[k];</b>
<i>429</i>&nbsp;            Node c;
<b class="nc"><i>430</i>&nbsp;            final int[] taxk = xclades[k];</b>
<b class="nc"><i>431</i>&nbsp;            if (taxk.length &gt; 1) {</b>
<i>432</i>&nbsp;                //  find MRCA of taxa
<b class="nc"><i>433</i>&nbsp;                c = getCommonAncestor(tree, taxk);</b>
<i>434</i>&nbsp;
<i>435</i>&nbsp;                // only monophyletics clades can be calibrated
<b class="nc"><i>436</i>&nbsp;                if (getLeafCount(c) != taxk.length) {</b>
<b class="nc"><i>437</i>&nbsp;                    return Double.NEGATIVE_INFINITY;</b>
<i>438</i>&nbsp;                }
<i>439</i>&nbsp;            } else {
<b class="nc"><i>440</i>&nbsp;                c = tree.getNode(taxk[0]);</b>
<b class="nc"><i>441</i>&nbsp;                assert cal.forParent();</b>
<i>442</i>&nbsp;            }
<i>443</i>&nbsp;
<b class="nc"><i>444</i>&nbsp;            if (cal.forParent()) {</b>
<b class="nc"><i>445</i>&nbsp;                c = c.getParent();</b>
<i>446</i>&nbsp;            }
<i>447</i>&nbsp;
<b class="nc"><i>448</i>&nbsp;            final double h = c.getHeight();</b>
<i>449</i>&nbsp;            // add calibration density for point
<b class="nc"><i>450</i>&nbsp;            if (calcCalibrations) {</b>
<b class="nc"><i>451</i>&nbsp;                logL += cal.logPdf(h);</b>
<i>452</i>&nbsp;            }
<i>453</i>&nbsp;
<b class="nc"><i>454</i>&nbsp;            hs[k] = h;</b>
<i>455</i>&nbsp;        }
<i>456</i>&nbsp;
<b class="nc"><i>457</i>&nbsp;        if (Double.isInfinite(logL)) {</b>
<i>458</i>&nbsp;            // some calibration points out of range
<b class="nc"><i>459</i>&nbsp;            return logL;</b>
<i>460</i>&nbsp;        }
<i>461</i>&nbsp;
<b class="nc"><i>462</i>&nbsp;        if (type == Type.NONE) {</b>
<b class="nc"><i>463</i>&nbsp;            return logL;</b>
<i>464</i>&nbsp;        }
<i>465</i>&nbsp;
<b class="nc"><i>466</i>&nbsp;        if (userPDF == null) {</b>
<b class="nc"><i>467</i>&nbsp;            switch (type) {</b>
<i>468</i>&nbsp;                case OVER_ALL_TOPOS: {
<b class="nc"><i>469</i>&nbsp;                    if (calCount == 1) {</b>
<b class="nc"><i>470</i>&nbsp;                        logL -= logMarginalDensity(lam, tree.getLeafNodeCount(), hs[0], xclades[0].length,</b>
<b class="nc"><i>471</i>&nbsp;                                orderedCalibrations[0].forParent());</b>
<b class="nc"><i>472</i>&nbsp;                    } else if (calCount == 2 &amp;&amp; taxaPartialOrder[1].length == 1) {</b>
<i>473</i>&nbsp;                        //assert !forParent[0] &amp;&amp; !forParent[1];
<b class="nc"><i>474</i>&nbsp;                        logL -= logMarginalDensity(lam, tree.getLeafNodeCount(), hs[0], xclades[0].length,</b>
<i>475</i>&nbsp;                                hs[1], xclades[1].length);
<i>476</i>&nbsp;                    } else {
<i>477</i>&nbsp;
<b class="nc"><i>478</i>&nbsp;                        if (lastLam == lam) {</b>
<b class="nc"><i>479</i>&nbsp;                            int k = 0;</b>
<b class="nc"><i>480</i>&nbsp;                            for (; k &lt; hs.length; ++k) {</b>
<b class="nc"><i>481</i>&nbsp;                                if (hs[k] != lastHeights[k]) {</b>
<b class="nc"><i>482</i>&nbsp;                                    break;</b>
<i>483</i>&nbsp;                                }
<i>484</i>&nbsp;                            }
<b class="nc"><i>485</i>&nbsp;                            if (k == hs.length) {</b>
<b class="nc"><i>486</i>&nbsp;                                return lastValue;</b>
<i>487</i>&nbsp;                            }
<i>488</i>&nbsp;                        }
<i>489</i>&nbsp;
<i>490</i>&nbsp;                        // the slow and painful way
<b class="nc"><i>491</i>&nbsp;                        final double[] hss = new double[hs.length];</b>
<b class="nc"><i>492</i>&nbsp;                        final int[] ranks = new int[hs.length];</b>
<b class="nc"><i>493</i>&nbsp;                        for (int k = 0; k &lt; hs.length; ++k) {</b>
<b class="nc"><i>494</i>&nbsp;                            int r = 0;</b>
<b class="nc"><i>495</i>&nbsp;                            for (int j = 0; j &lt; k; ++j) {</b>
<b class="nc"><i>496</i>&nbsp;                                r += (hs[j] &lt;= hs[k]) ? 1 : 0;</b>
<i>497</i>&nbsp;                            }
<b class="nc"><i>498</i>&nbsp;                            for (int j = k + 1; j &lt; hs.length; ++j) {</b>
<b class="nc"><i>499</i>&nbsp;                                r += (hs[j] &lt; hs[k]) ? 1 : 0;</b>
<i>500</i>&nbsp;                            }
<i>501</i>&nbsp;//                            for (final double h : hs) {
<i>502</i>&nbsp;//                                r += (h &lt; hs[k]) ? 1 : 0;
<i>503</i>&nbsp;//                            }
<b class="nc"><i>504</i>&nbsp;                            ranks[k] = r + 1;</b>
<b class="nc"><i>505</i>&nbsp;                            hss[r] = hs[k];</b>
<i>506</i>&nbsp;                        }
<b class="nc"><i>507</i>&nbsp;                        logL -= logMarginalDensity(lam, hss, ranks, linsIter);</b>
<i>508</i>&nbsp;
<b class="nc"><i>509</i>&nbsp;                        lastLam = lam;</b>
<b class="nc"><i>510</i>&nbsp;                        System.arraycopy(hs, 0, lastHeights, 0, lastHeights.length);</b>
<b class="nc"><i>511</i>&nbsp;                        lastValue = logL;</b>
<i>512</i>&nbsp;                    }
<b class="nc"><i>513</i>&nbsp;                    break;</b>
<i>514</i>&nbsp;                }
<i>515</i>&nbsp;
<i>516</i>&nbsp;                case OVER_RANKED_COUNTS: {
<b class="nc"><i>517</i>&nbsp;                    Arrays.sort(hs);</b>
<b class="nc"><i>518</i>&nbsp;                    final int[] cs = new int[calCount + 1];</b>
<b class="nc"><i>519</i>&nbsp;                    for (final Node n : tree.getInternalNodes()) {</b>
<b class="nc"><i>520</i>&nbsp;                        final double nhk = n.getHeight();</b>
<b class="nc"><i>521</i>&nbsp;                        int i = 0;</b>
<b class="nc"><i>522</i>&nbsp;                        for (/**/; i &lt; hs.length; ++i) {</b>
<b class="nc"><i>523</i>&nbsp;                            if (hs[i] &gt;= nhk) {</b>
<b class="nc"><i>524</i>&nbsp;                                break;</b>
<i>525</i>&nbsp;                            }
<i>526</i>&nbsp;                        }
<b class="nc"><i>527</i>&nbsp;                        if (i == hs.length) {</b>
<b class="nc"><i>528</i>&nbsp;                            cs[i]++;</b>
<i>529</i>&nbsp;                        } else {
<b class="nc"><i>530</i>&nbsp;                            if (nhk &lt; hs[i]) {</b>
<b class="nc"><i>531</i>&nbsp;                                cs[i]++;</b>
<i>532</i>&nbsp;                            }
<i>533</i>&nbsp;                        }
<b class="nc"><i>534</i>&nbsp;                    }</b>
<i>535</i>&nbsp;
<b class="nc"><i>536</i>&nbsp;                    double ll = 0;</b>
<i>537</i>&nbsp;
<b class="nc"><i>538</i>&nbsp;                    ll += cs[0] * Math.log1p(-Math.exp(-lam * hs[0])) - lam * hs[0] - lfactorials[cs[0]];</b>
<b class="nc"><i>539</i>&nbsp;                    for (int i = 1; i &lt; cs.length - 1; ++i) {</b>
<b class="nc"><i>540</i>&nbsp;                        final int c = cs[i];</b>
<b class="nc"><i>541</i>&nbsp;                        ll += c * (Math.log1p(-Math.exp(-lam * (hs[i] - hs[i - 1]))) - lam * hs[i - 1]);</b>
<b class="nc"><i>542</i>&nbsp;                        ll += -lam * hs[i] - lfactorials[c];</b>
<i>543</i>&nbsp;                    }
<b class="nc"><i>544</i>&nbsp;                    ll += -lam * (cs[calCount] + 1) * hs[calCount - 1] - lfactorials[cs[calCount] + 1];</b>
<b class="nc"><i>545</i>&nbsp;                    ll += Math.log(lam) * calCount;</b>
<i>546</i>&nbsp;
<b class="nc"><i>547</i>&nbsp;                    logL -= ll;</b>
<b class="nc"><i>548</i>&nbsp;                    break;</b>
<i>549</i>&nbsp;                }
<i>550</i>&nbsp;			default:
<b class="nc"><i>551</i>&nbsp;				break;</b>
<i>552</i>&nbsp;            }
<i>553</i>&nbsp;        } else {
<b class="nc"><i>554</i>&nbsp;            final double value = userPDF.getArrayValue();</b>
<b class="nc"><i>555</i>&nbsp;            if (Double.isNaN(value) || Double.isInfinite(value)) {</b>
<b class="nc"><i>556</i>&nbsp;                logL = Double.NEGATIVE_INFINITY;</b>
<i>557</i>&nbsp;            } else {
<b class="nc"><i>558</i>&nbsp;                logL -= value;</b>
<i>559</i>&nbsp;            }
<i>560</i>&nbsp;        }
<b class="nc"><i>561</i>&nbsp;        return logL;</b>
<i>562</i>&nbsp;    }
<i>563</i>&nbsp;
<i>564</i>&nbsp;    private static double logMarginalDensity(final double lam, final int taxonCount, final double h, final int clade,
<i>565</i>&nbsp;                                             final boolean forParent) {
<i>566</i>&nbsp;        double lgp;
<i>567</i>&nbsp;
<b class="nc"><i>568</i>&nbsp;        final double lh = lam * h;</b>
<i>569</i>&nbsp;
<b class="nc"><i>570</i>&nbsp;        if (forParent) {</b>
<i>571</i>&nbsp;            // n(n+1) factor left out
<i>572</i>&nbsp;
<b class="nc"><i>573</i>&nbsp;            lgp = -2 * lh + Math.log(lam);</b>
<b class="nc"><i>574</i>&nbsp;            if (clade &gt; 1) {</b>
<b class="nc"><i>575</i>&nbsp;                lgp += (clade - 1) * Math.log(1 - Math.exp(-lh));</b>
<i>576</i>&nbsp;            }
<i>577</i>&nbsp;        } else {
<b class="nc"><i>578</i>&nbsp;            assert clade &gt; 1;</b>
<i>579</i>&nbsp;
<b class="nc"><i>580</i>&nbsp;            lgp = -3 * lh + (clade - 2) * Math.log(1 - Math.exp(-lh)) + Math.log(lam);</b>
<i>581</i>&nbsp;
<i>582</i>&nbsp;            // root is a special case
<b class="nc"><i>583</i>&nbsp;            if (taxonCount == clade) {</b>
<i>584</i>&nbsp;                // n(n-1) factor left out
<b class="nc"><i>585</i>&nbsp;                lgp += lh;</b>
<i>586</i>&nbsp;            } else {
<i>587</i>&nbsp;                // (n^3-n)/2 factor left out
<i>588</i>&nbsp;            }
<i>589</i>&nbsp;        }
<i>590</i>&nbsp;
<b class="nc"><i>591</i>&nbsp;        return lgp;</b>
<i>592</i>&nbsp;    }
<i>593</i>&nbsp;
<i>594</i>&nbsp;    private static double logMarginalDensity(final double lam, final int taxonCount, final double h2, final int n,
<i>595</i>&nbsp;                                             final double h1, final int nm) {
<i>596</i>&nbsp;
<b class="nc"><i>597</i>&nbsp;        assert h2 &lt;= h1 &amp;&amp; n &lt; nm;</b>
<i>598</i>&nbsp;
<b class="nc"><i>599</i>&nbsp;        final int m = nm - n;</b>
<i>600</i>&nbsp;
<b class="nc"><i>601</i>&nbsp;        final double elh2 = Math.exp(-lam * h2);</b>
<b class="nc"><i>602</i>&nbsp;        final double elh1 = Math.exp(-lam * h1);</b>
<i>603</i>&nbsp;
<b class="nc"><i>604</i>&nbsp;        double lgl = 2 * Math.log(lam);</b>
<i>605</i>&nbsp;
<b class="nc"><i>606</i>&nbsp;        lgl += (n - 2) * Math.log(1 - elh2);</b>
<b class="nc"><i>607</i>&nbsp;        lgl += (m - 3) * Math.log(1 - elh1);</b>
<i>608</i>&nbsp;
<b class="nc"><i>609</i>&nbsp;        lgl += Math.log(1 - 2 * m * elh1 + 2 * (m - 1) * elh2</b>
<i>610</i>&nbsp;                - m * (m - 1) * elh1 * elh2 + (m * (m + 1) / 2.) * elh1 * elh1
<i>611</i>&nbsp;                + ((m - 1) * (m - 2) / 2.) * elh2 * elh2);
<i>612</i>&nbsp;
<b class="nc"><i>613</i>&nbsp;        if (nm &lt; taxonCount) {</b>
<i>614</i>&nbsp;            /* lgl += Math.log(0.5*(n*(n*n-1))*(n+1+m)) */
<b class="nc"><i>615</i>&nbsp;            lgl -= lam * (h2 + 3 * h1);</b>
<i>616</i>&nbsp;        } else {
<i>617</i>&nbsp;            /* lgl += Math.log(lam) /* + Math.log(n*(n*n-1)) */
<b class="nc"><i>618</i>&nbsp;            lgl -= lam * (h2 + 2 * h1);</b>
<i>619</i>&nbsp;        }
<i>620</i>&nbsp;
<b class="nc"><i>621</i>&nbsp;        return lgl;</b>
<i>622</i>&nbsp;    }
<i>623</i>&nbsp;
<i>624</i>&nbsp;    private double logMarginalDensity(final double lam, final double[] hs, final int[] ranks,
<i>625</i>&nbsp;                                      final CalibrationLineagesIterator cli) {
<i>626</i>&nbsp;
<b class="nc"><i>627</i>&nbsp;        final int ni = cli.setup(ranks);</b>
<i>628</i>&nbsp;
<b class="nc"><i>629</i>&nbsp;        final int heights = hs.length;</b>
<i>630</i>&nbsp;
<b class="nc"><i>631</i>&nbsp;        final double[] lehs = new double[heights + 1];</b>
<b class="nc"><i>632</i>&nbsp;        lehs[0] = 0.0;</b>
<b class="nc"><i>633</i>&nbsp;        for (int i = 1; i &lt; lehs.length; ++i) {</b>
<b class="nc"><i>634</i>&nbsp;            lehs[i] = -lam * hs[i - 1];</b>
<i>635</i>&nbsp;        }
<i>636</i>&nbsp;
<i>637</i>&nbsp;        // assert maxRank == len(sit)
<b class="nc"><i>638</i>&nbsp;        final boolean noRoot = ni == lehs.length;</b>
<i>639</i>&nbsp;
<b class="nc"><i>640</i>&nbsp;        final int levels = heights + (noRoot ? 1 : 0);</b>
<i>641</i>&nbsp;
<b class="nc"><i>642</i>&nbsp;        final double[] lebase = new double[levels];</b>
<i>643</i>&nbsp;
<b class="nc"><i>644</i>&nbsp;        for (int i = 0; i &lt; heights; ++i) {</b>
<b class="nc"><i>645</i>&nbsp;            final double d = lehs[i + 1] - lehs[i];</b>
<b class="nc"><i>646</i>&nbsp;            lebase[i] = d != 0 ? lehs[i] + Math.log1p(-Math.exp(d)) : -50;</b>
<i>647</i>&nbsp;        }
<i>648</i>&nbsp;
<b class="nc"><i>649</i>&nbsp;        if (noRoot) {</b>
<b class="nc"><i>650</i>&nbsp;            lebase[heights] = lehs[heights];</b>
<i>651</i>&nbsp;        }
<i>652</i>&nbsp;
<b class="nc"><i>653</i>&nbsp;        final int[] linsAtLevel = new int[levels];</b>
<i>654</i>&nbsp;
<b class="nc"><i>655</i>&nbsp;        final int[][] joiners = cli.allJoiners();</b>
<i>656</i>&nbsp;
<b class="nc"><i>657</i>&nbsp;        double val = 0;</b>
<b class="nc"><i>658</i>&nbsp;        boolean first = true;</b>
<i>659</i>&nbsp;
<i>660</i>&nbsp;        int[][] linsInLevels;
<i>661</i>&nbsp;        //int ccc = 0;
<b class="nc"><i>662</i>&nbsp;        while ((linsInLevels = cli.next()) != null) {</b>
<i>663</i>&nbsp;            //ccc++;
<b class="nc"><i>664</i>&nbsp;            double v = countRankedTrees(levels, linsInLevels, joiners, linsAtLevel);</b>
<i>665</i>&nbsp;            // 1 for root formula, 1 for kludge in iterator which sets root as 2 lineages
<b class="nc"><i>666</i>&nbsp;            if (noRoot) {</b>
<b class="nc"><i>667</i>&nbsp;                final int ll = linsAtLevel[levels - 1] + 2;</b>
<b class="nc"><i>668</i>&nbsp;                linsAtLevel[levels - 1] = ll;</b>
<i>669</i>&nbsp;
<b class="nc"><i>670</i>&nbsp;                v -= lc2[ll] + lg2;</b>
<i>671</i>&nbsp;            }
<i>672</i>&nbsp;
<b class="nc"><i>673</i>&nbsp;            for (int i = 0; i &lt; levels; ++i) {</b>
<b class="nc"><i>674</i>&nbsp;                v += linsAtLevel[i] * lebase[i];</b>
<i>675</i>&nbsp;            }
<i>676</i>&nbsp;
<b class="nc"><i>677</i>&nbsp;            if (first) {</b>
<b class="nc"><i>678</i>&nbsp;                val = v;</b>
<b class="nc"><i>679</i>&nbsp;                first = false;</b>
<i>680</i>&nbsp;            } else {
<b class="nc"><i>681</i>&nbsp;                if (val &gt; v) {</b>
<b class="nc"><i>682</i>&nbsp;                    val += Math.log1p(Math.exp(v - val));</b>
<i>683</i>&nbsp;                } else {
<b class="nc"><i>684</i>&nbsp;                    val = v + Math.log1p(Math.exp(val - v));</b>
<i>685</i>&nbsp;                }
<i>686</i>&nbsp;            }
<b class="nc"><i>687</i>&nbsp;        }</b>
<i>688</i>&nbsp;
<b class="nc"><i>689</i>&nbsp;        double logc0 = 0.0;</b>
<b class="nc"><i>690</i>&nbsp;        int totLin = 0;</b>
<b class="nc"><i>691</i>&nbsp;        for (int i = 0; i &lt; ni; ++i) {</b>
<b class="nc"><i>692</i>&nbsp;            final int l = cli.start(i);</b>
<b class="nc"><i>693</i>&nbsp;            if (l &gt; 0) {</b>
<b class="nc"><i>694</i>&nbsp;                logc0 += lNR[l];</b>
<b class="nc"><i>695</i>&nbsp;                totLin += l;</b>
<i>696</i>&nbsp;            }
<i>697</i>&nbsp;        }
<i>698</i>&nbsp;
<b class="nc"><i>699</i>&nbsp;        final double logc1 = lfactorials[totLin];</b>
<i>700</i>&nbsp;
<b class="nc"><i>701</i>&nbsp;        double logc2 = heights * Math.log(lam);</b>
<i>702</i>&nbsp;
<b class="nc"><i>703</i>&nbsp;        for (int i = 1; i &lt; heights + 1; ++i) {</b>
<b class="nc"><i>704</i>&nbsp;            logc2 += lehs[i];</b>
<i>705</i>&nbsp;        }
<i>706</i>&nbsp;
<b class="nc"><i>707</i>&nbsp;        if (!noRoot) {</b>
<i>708</i>&nbsp;            // we dont have an iterator for 0 free lineages
<b class="nc"><i>709</i>&nbsp;            logc2 += 1 * lehs[heights];</b>
<i>710</i>&nbsp;        }
<i>711</i>&nbsp;
<i>712</i>&nbsp;        // Missing scale by total of all possible trees over all ranking orders.
<i>713</i>&nbsp;        // Add it outside if needed for comparison.
<i>714</i>&nbsp;
<b class="nc"><i>715</i>&nbsp;        val += logc0 + logc1 + logc2;</b>
<i>716</i>&nbsp;
<b class="nc"><i>717</i>&nbsp;        return val;</b>
<i>718</i>&nbsp;    }
<i>719</i>&nbsp;
<i>720</i>&nbsp;    private double
<i>721</i>&nbsp;    countRankedTrees(final int levels, final int[][] linsAtCrossings, final int[][] joiners, final int[] linsAtLevel) {
<b class="nc"><i>722</i>&nbsp;        double logCount = 0;</b>
<i>723</i>&nbsp;
<b class="nc"><i>724</i>&nbsp;        for (int i = 0; i &lt; levels; ++i) {</b>
<b class="nc"><i>725</i>&nbsp;            int sumLins = 0;</b>
<b class="nc"><i>726</i>&nbsp;            for (int k = i; k &lt; levels; ++k) {</b>
<b class="nc"><i>727</i>&nbsp;                final int[] lack = linsAtCrossings[k];</b>
<b class="nc"><i>728</i>&nbsp;                int cki = lack[i];</b>
<b class="nc"><i>729</i>&nbsp;                if (joiners[k][i] &gt; 0) {</b>
<b class="nc"><i>730</i>&nbsp;                    ++cki;</b>
<b class="nc"><i>731</i>&nbsp;                    if (cki &gt; 1) {</b>
<i>732</i>&nbsp;                        // can be 1 if iterator without lins - for joiners only - need to check this is correct
<b class="nc"><i>733</i>&nbsp;                        logCount += lc2[cki];</b>
<i>734</i>&nbsp;                    } //assert(cki &gt;= 2);
<i>735</i>&nbsp;                }
<b class="nc"><i>736</i>&nbsp;                final int l = cki - lack[i + 1];   //assert(l &gt;= 0);</b>
<b class="nc"><i>737</i>&nbsp;                logCount -= lfactorials[l];</b>
<b class="nc"><i>738</i>&nbsp;                sumLins += l;</b>
<i>739</i>&nbsp;            }
<b class="nc"><i>740</i>&nbsp;            linsAtLevel[i] = sumLins;</b>
<i>741</i>&nbsp;        }
<i>742</i>&nbsp;
<b class="nc"><i>743</i>&nbsp;        return logCount;</b>
<i>744</i>&nbsp;    }
<i>745</i>&nbsp;
<b class="nc"><i>746</i>&nbsp;    private CalibrationLineagesIterator linsIter = null;</b>
<i>747</i>&nbsp;
<b class="nc"><i>748</i>&nbsp;    double lastLam = Double.NEGATIVE_INFINITY;</b>
<i>749</i>&nbsp;    double[] lastHeights;
<b class="nc"><i>750</i>&nbsp;    double lastValue = Double.NEGATIVE_INFINITY;</b>
<i>751</i>&nbsp;
<i>752</i>&nbsp;    // speedup constants
<b class="nc"><i>753</i>&nbsp;    private final double lg2 = Math.log(2.0);</b>
<i>754</i>&nbsp;    private double[] lc2;
<i>755</i>&nbsp;    private double[] lNR;
<i>756</i>&nbsp;    private double[] lfactorials;
<i>757</i>&nbsp;
<i>758</i>&nbsp;    private void setUpTables(final int MAX_N) {
<b class="nc"><i>759</i>&nbsp;        final double[] lints = new double[MAX_N];</b>
<b class="nc"><i>760</i>&nbsp;        lc2 = new double[MAX_N];</b>
<b class="nc"><i>761</i>&nbsp;        lfactorials = new double[MAX_N];</b>
<b class="nc"><i>762</i>&nbsp;        lNR = new double[MAX_N];</b>
<i>763</i>&nbsp;
<b class="nc"><i>764</i>&nbsp;        lints[0] = Double.NEGATIVE_INFINITY; //-infinity, should never be used</b>
<b class="nc"><i>765</i>&nbsp;        lints[1] = 0.0;</b>
<b class="nc"><i>766</i>&nbsp;        for (int i = 2; i &lt; MAX_N; ++i) {</b>
<b class="nc"><i>767</i>&nbsp;            lints[i] = Math.log(i);</b>
<i>768</i>&nbsp;        }
<i>769</i>&nbsp;
<b class="nc"><i>770</i>&nbsp;        lc2[0] = lc2[1] = Double.NEGATIVE_INFINITY;</b>
<b class="nc"><i>771</i>&nbsp;        for (int i = 2; i &lt; MAX_N; ++i) {</b>
<b class="nc"><i>772</i>&nbsp;            lc2[i] = lints[i] + lints[i - 1] - lg2;</b>
<i>773</i>&nbsp;        }
<i>774</i>&nbsp;
<b class="nc"><i>775</i>&nbsp;        lfactorials[0] = 0.0;</b>
<b class="nc"><i>776</i>&nbsp;        for (int i = 1; i &lt; MAX_N; ++i) {</b>
<b class="nc"><i>777</i>&nbsp;            lfactorials[i] = lfactorials[i - 1] + lints[i];</b>
<i>778</i>&nbsp;        }
<i>779</i>&nbsp;
<b class="nc"><i>780</i>&nbsp;        lNR[0] = Double.NEGATIVE_INFINITY; //-infinity, should never be used</b>
<b class="nc"><i>781</i>&nbsp;        lNR[1] = 0.0;</b>
<i>782</i>&nbsp;
<b class="nc"><i>783</i>&nbsp;        for (int i = 2; i &lt; MAX_N; ++i) {</b>
<b class="nc"><i>784</i>&nbsp;            lNR[i] = lNR[i - 1] + lc2[i];</b>
<i>785</i>&nbsp;        }
<i>786</i>&nbsp;    }
<i>787</i>&nbsp;
<i>788</i>&nbsp;    // @return true if the k&#39;th taxa is maximal under set inclusion, i.e. it is not contained in any other set
<i>789</i>&nbsp;    public static boolean isMaximal(final List&lt;TaxonSet&gt; taxa, final int k) {
<b class="nc"><i>790</i>&nbsp;        final TaxonSet tk = taxa.get(k);</b>
<b class="nc"><i>791</i>&nbsp;        for (int i = 0; i &lt; taxa.size(); ++i) {</b>
<b class="nc"><i>792</i>&nbsp;            if (i != k) {</b>
<b class="nc"><i>793</i>&nbsp;                if (taxa.get(i).containsAll(tk)) {</b>
<b class="nc"><i>794</i>&nbsp;                    return false;</b>
<i>795</i>&nbsp;                }
<i>796</i>&nbsp;            }
<i>797</i>&nbsp;        }
<b class="nc"><i>798</i>&nbsp;        return true;</b>
<i>799</i>&nbsp;    }
<i>800</i>&nbsp;
<i>801</i>&nbsp;
<i>802</i>&nbsp;    // Q2R Those generic functions could find a better home
<i>803</i>&nbsp;
<i>804</i>&nbsp;    public static int getTaxonIndex(final TreeInterface tree, final String taxon) {
<b class="nc"><i>805</i>&nbsp;        for (int i = 0; i &lt; tree.getNodeCount(); i++) {</b>
<b class="nc"><i>806</i>&nbsp;            final Node node = tree.getNode(i);</b>
<b class="nc"><i>807</i>&nbsp;            if (node.isLeaf() &amp;&amp; node.getID().equals(taxon)) {</b>
<b class="nc"><i>808</i>&nbsp;                return i;</b>
<i>809</i>&nbsp;            }
<i>810</i>&nbsp;        }
<b class="nc"><i>811</i>&nbsp;        return -1;</b>
<i>812</i>&nbsp;    }
<i>813</i>&nbsp;
<i>814</i>&nbsp;    public static Node getCommonAncestor(Node n1, Node n2) {
<i>815</i>&nbsp;        // assert n1.getTree() == n2.getTree();
<b class="nc"><i>816</i>&nbsp;        while (n1 != n2) {</b>
<b class="nc"><i>817</i>&nbsp;            if (n1.getHeight() &lt; n2.getHeight()) {</b>
<b class="nc"><i>818</i>&nbsp;                n1 = n1.getParent();</b>
<i>819</i>&nbsp;            } else {
<b class="nc"><i>820</i>&nbsp;                n2 = n2.getParent();</b>
<i>821</i>&nbsp;            }
<i>822</i>&nbsp;        }
<b class="nc"><i>823</i>&nbsp;        return n1;</b>
<i>824</i>&nbsp;    }
<i>825</i>&nbsp;
<i>826</i>&nbsp;    // A lightweight version for finding the most recent common ancestor of a group of taxa.
<i>827</i>&nbsp;    // return the node-ref of the MRCA.
<i>828</i>&nbsp;
<i>829</i>&nbsp;    // would be nice to use nodeRef&#39;s, but they are not preserved :(
<i>830</i>&nbsp;    public static Node getCommonAncestor(final TreeInterface tree, final int[] nodes) {
<b class="nc"><i>831</i>&nbsp;        Node cur = tree.getNode(nodes[0]);</b>
<i>832</i>&nbsp;
<b class="nc"><i>833</i>&nbsp;        for (int k = 1; k &lt; nodes.length; ++k) {</b>
<b class="nc"><i>834</i>&nbsp;            cur = getCommonAncestor(cur, tree.getNode(nodes[k]));</b>
<i>835</i>&nbsp;        }
<b class="nc"><i>836</i>&nbsp;        return cur;</b>
<i>837</i>&nbsp;    }
<i>838</i>&nbsp;
<i>839</i>&nbsp;    /**
<i>840</i>&nbsp;     * Count number of leaves in subtree whose root is node.
<i>841</i>&nbsp;     *
<i>842</i>&nbsp;     * @param node
<i>843</i>&nbsp;     * @return the number of leaves under this node.
<i>844</i>&nbsp;     */
<i>845</i>&nbsp;    public static int getLeafCount(final Node node) {
<b class="nc"><i>846</i>&nbsp;        if (node.isLeaf()) {</b>
<b class="nc"><i>847</i>&nbsp;            return 1;</b>
<i>848</i>&nbsp;        }
<b class="nc"><i>849</i>&nbsp;        return getLeafCount(node.getLeft()) + getLeafCount(node.getRight());</b>
<i>850</i>&nbsp;    }
<i>851</i>&nbsp;
<i>852</i>&nbsp;    // log likelihood and clades heights
<i>853</i>&nbsp;
<i>854</i>&nbsp;    @Override
<i>855</i>&nbsp;    public void init(final PrintStream out) {
<b class="nc"><i>856</i>&nbsp;        out.print(getID() + &quot;\t&quot;);</b>
<b class="nc"><i>857</i>&nbsp;        if (calcCalibrations) {</b>
<b class="nc"><i>858</i>&nbsp;            for (final CalibrationPoint cp : orderedCalibrations) {</b>
<b class="nc"><i>859</i>&nbsp;                out.print(cp.getID() + &quot;\t&quot;);</b>
<i>860</i>&nbsp;            }
<i>861</i>&nbsp;        }
<i>862</i>&nbsp;    }
<i>863</i>&nbsp;
<i>864</i>&nbsp;    @Override
<i>865</i>&nbsp;    public void log(final int sample, final PrintStream out) {
<b class="nc"><i>866</i>&nbsp;        out.print(getCurrentLogP() + &quot;\t&quot;);</b>
<b class="nc"><i>867</i>&nbsp;        if (calcCalibrations) {</b>
<b class="nc"><i>868</i>&nbsp;            final TreeInterface tree = treeInput.get();</b>
<b class="nc"><i>869</i>&nbsp;            for (int k = 0; k &lt; orderedCalibrations.length; ++k) {</b>
<b class="nc"><i>870</i>&nbsp;                final CalibrationPoint cal = orderedCalibrations[k];</b>
<i>871</i>&nbsp;                Node c;
<b class="nc"><i>872</i>&nbsp;                final int[] taxk = xclades[k];</b>
<b class="nc"><i>873</i>&nbsp;                if (taxk.length &gt; 1) {</b>
<i>874</i>&nbsp;                    //  find MRCA of taxa
<b class="nc"><i>875</i>&nbsp;                    c = getCommonAncestor(tree, taxk);</b>
<i>876</i>&nbsp;                } else {
<b class="nc"><i>877</i>&nbsp;                    c = tree.getNode(taxk[0]);</b>
<i>878</i>&nbsp;                }
<i>879</i>&nbsp;
<b class="nc"><i>880</i>&nbsp;                if (cal.forParent()) {</b>
<b class="nc"><i>881</i>&nbsp;                    c = c.getParent();</b>
<i>882</i>&nbsp;                }
<i>883</i>&nbsp;
<b class="nc"><i>884</i>&nbsp;                final double h = c.getHeight();</b>
<b class="nc"><i>885</i>&nbsp;                out.print(h + &quot;\t&quot;);</b>
<i>886</i>&nbsp;            }
<i>887</i>&nbsp;        }
<i>888</i>&nbsp;    }
<i>889</i>&nbsp;
<i>890</i>&nbsp;    @Override
<i>891</i>&nbsp;    protected boolean requiresRecalculation() {
<b class="nc"><i>892</i>&nbsp;        return super.requiresRecalculation() || birthRateInput.get().somethingIsDirty();</b>
<i>893</i>&nbsp;    }
<i>894</i>&nbsp;
<i>895</i>&nbsp;    @Override
<i>896</i>&nbsp;    public boolean canHandleTipDates() {
<b class="nc"><i>897</i>&nbsp;        return false;</b>
<i>898</i>&nbsp;    }
<i>899</i>&nbsp;
<i>900</i>&nbsp;
<i>901</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2016-05-30 16:46</div>
</div>
</body>
</html>
